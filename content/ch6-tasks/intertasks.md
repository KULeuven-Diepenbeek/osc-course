---
title: '6.5: Inter task communication'
pre: "<i class='fas fa-book'></i> "
weight: 5
draft: true
---

!! DEPRECATED: SPLIT OUT INTO IPC and Inter-Thread separately !! 


Having multiple tasks running is all good-and-well. Hey, it is one of the main reasons why the concept of an OS was introduced, remember ? Right, **good job !!**

It would make sense, though, if different tasks were able to communicate with each other. A distinction should be made between multi-processes and multi-threading. Although both techniques are made for running multiple jobs, the communication between the jobs is much different in both.


## Communication between processes

There are two main techniques to facilitate communication between multiple processes. These two techniques are shown in image below.

1. Shared memory
2. Message passing

{{% figure src="/img/os/db_ipc.png" title="The two main techniques for inter process communication" %}}
{{% dinobook %}}

### Shared memory

Shared memory is ... memory that is shared. Normally multiple processes are not allowed to read/write to each other's memory space. This is enforced by the operating system. Errors, similar to the one in the example below, are generated by the OS if a processes try to access areas that it is not allowed to access.

```C
#include <stdio.h>

int main(void) {
  int i, my_array[8];

  for(i=0;i<=8;i++) {
    my_array[i] = i+1;
  }

  for(i=0;i<8;i++) {
    printf("%d\n", my_array[i]);
  }

  return 0;
}
```

{{% figure src="/img/os/sc_stacksmashing.png" title="An example of memory protection that given by the OS" %}}

{{% task %}}
The code above exceeds the allowed stack space. Try to find out why this happens.
{{% /task %}}

The technique of using **shared memory** allows other processes to gain access certain regions of the address space. Both processes have to be aware that the memory is **not** protected by the OS. A programming API for using shared memory is provided by POSIX (Portable Operating System Interface). The example below shows a **producer** on the left (a process which puts data inside of the shared memory) and a **consumer** on the right (which uses the data it gets from the producer).

<div class="multicolumn">
  <div class="column">
  {{< highlight c >}}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/shm.h>
#include <sys/mman.h>

int main() {
  const int SIZE = 4096; /* buffersize (bytes) */
  const char *name = "OS"; /* shared memory object name */
  const char *data_0 = "Hello";
  const char *data_1 = "World!";
  int shm_fd; /* shared memory file descriptor */
  void *ptr;

  /* create the shared memory file descriptor */
  shm_fd = shm_open(name, O_CREAT | O_RDWR, 0666);

  /* configure the size of the shared memory file */
  ftruncate(shm_fd, SIZE);

  /* memory map the shared memory file */
  ptr = mmap(0, SIZE, PROT_WRITE, MAP_SHARED, shm_fd, 0);

  /* write to the shared memory file */
  sprintf(ptr,"%s",data_0);
  ptr += strlen(data_0);
  sprintf(ptr,"%s",data_1);
  ptr += strlen(data_1);

  return 0;
}
  {{< /highlight >}}
  </div>
  <div class="column">
  {{< highlight c >}}
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/shm.h>
#include <sys/mman.h>


int main() {
  const int SIZE = 4096; /* buffersize (bytes) */
  const char *name = "OS"; /* shared memory object name */


  int shm_fd; /* file descriptor */
  void *ptr;

  /* open the shared memory file */
  shm_fd = shm_open(name, O_RDONLY, 0666);


  /* memory map the shared memory file */
  ptr = mmap(0, SIZE, PROT_READ, MAP_SHARED, shm_fd, 0);


  /* read from the shared memory file */
  printf("%s",(char *)ptr);

  /* remove the shared memory file */
  shm_unlink(name);

  return 0;
}
  {{< /highlight >}}
  </div>
</div>
{{% dinobook %}}

**Note:** to compile these, you need to pass the `-lrt` flag to gcc ("link with library rt") like so: `gcc -o producer producer.c -lrt`.

{{% task %}}
This very simple example uses shared memory. Try to find answers to the questions below:

* Try to find out what these programs do
* What is the size of the memory that is shared ?
* Can a *producer* read from the shared memory ?
* Can a *consumer* write to the shared memory ?
* How do both processes know which data is shared ? In other words, how does the consumer decide which memory it connects to?
* Do both processes have to be active at the same time for the memory sharing to work? Why (not)?
{{% /task %}}

### Message passing

The second technique for for InterProcess Communication (IPC) comes in the form of message passing. This method is a bit more restricted than using raw shared memory, but also easier to use ans safer because of that. Here we touch on 2 different mechanisms for achieving this: **signals** and **pipes**.

#### Signals

Signals are the cheapest form of IPC. They literally allows one process to send a signal to another process, through the use of the function **kill()**. Although the name might be a bit misleading, it can be used to send different signals. These signals are conceptually a bit similar to the Interrupts we saw in Chapter 2: they allow a program to act on information coming in from the outside without itself having requested it. The snippet below shows the different types of signals that can be sent:

```bash
jvliegen@localhost:~/$ kill -L
 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL   5) SIGTRAP
 6) SIGABRT  7) SIGBUS   8) SIGFPE   9) SIGKILL 10) SIGUSR1
11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM
16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP
21) SIGTTIN 22) SIGTTOU 23) SIGURG  24) SIGXCPU 25) SIGXFSZ
26) SIGVTALRM 27) SIGPROF 28) SIGWINCH  29) SIGIO 30) SIGPWR
31) SIGSYS  34) SIGRTMIN  35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX   
```

There is also has CLI-compatible command **kill** that can send these signals to any running process (addressed by their PID). For more information on the kill command, add the ```--help``` argument, read the man-page (```man kill```), or ask the Internet.

Two short-cuts are typically available in the CLI that allow for the sending of signals: CTRL+C and CTRL+Z. The former sends a **SIGINT** signal while the latter sends a **SIGTSTP** signal.

Let's illustrate this with an example:

```C
#include <stdio.h>
#include <unistd.h>

#define DURATION_IN_MINUTES 10

int main(void) {
  int i = DURATION_IN_MINUTES * 60;

  for(;i>=0;i--) {
    printf("TIMER: 00:%02d:%02d\n", (int)((i-i%60)/60), i%60);
    sleep(1);
  }

  return 0;
}
```

This program will emulate an egg timer. Every second it displays how much time is left. Once the process starts running, it takes 10 minutes to complete. This process can be **killed** by just pressing CTRL+C. Note that you don't have to manually do anything for this to work: your program automatically listens for this signal and exits the program when it is received.

```bash
jvliegen@localhost:~/$ ./egg_timer.bin 
TIMER: 00:10:00
TIMER: 00:09:59
TIMER: 00:09:58
TIMER: 00:09:57
TIMER: 00:09:56
^C
```

Another way to kill the process would be to explicitly send the signal through the kill command. To use this command, the **PID** is needed as an argument. Through a new CLI-window, this PID has to be searched for first. Note that the type of signal is an argument in the command.

```bash
jvliegen@localhost:~/$  ps ux | grep timer
jvliegen  5041  0.0  0.0   4504   772 pts/1    S+   06:04   0:00 ./egg_timer.bin
jvliegen  5066  0.0  0.0  21996  1080 pts/2    S+   06:05   0:00 grep --color=auto timer
jvliegen@localhost:~/$  kill -KILL 5041
```

{{% task %}}
Try this for yourself. You can use the *longhello* program (\~/osc-exercises/ch6_tasks/longhello.c) from Section 6.1. Run this program and try to kill it using **both** approaches that were explained above. (Ofcourse this means you shoud run it again, after you killed it the first time :smiley: )
{{% /task %}}

Although there are numerous uses for sending signals between signals, one more example is interesting to have a closer look at. Above there was already some hinting to **CTRL+Z**. 

The CLI is running a shell, as you already know by now. This offers just a single interface. If you were to start a program, that CLI is occupied (you cannot type or execute any commands). Imagine you are working remotely on a server (e.g., through ssh): this would require you to open up a new connection to the server and have a second shell at your disposal every time you executed a longer running command (e.g., starting a web server). A more convenient solution would be to send the running program to the **background**.

{{% figure src="/img/os/sc_xeyes.png" title="An example of a program that needs to be killed with CTRL-C" %}}

Before you can send processes to the background, the process has to be halted first. This can be done through the CTRL+Z shortcut. With a halted process, the command **bg** sends the halted process to the background. If you do not send it to the background, the process will *freeze*. Once it is in the background it *unfreezes* and continues running. Additionally, this gives you back your shell.

```bash
jvliegen@localhost:~/$ xeyes 
^Z
[1]+  Stopped                 xeyes
jvliegen@localhost:~/$ bg
[1]+ xeyes &
jvliegen@localhost:~/$ 
```

For the sake of completeness we enumerate a few more usefull aspects about this:

* a process can be started in the background as well. This can be achieved by adding an **ampersand** after the command (e.g., xeyes &)
* the command **jobs** gives you an overview of which jobs are running in the background
* through the command **fg <#>** the job with index number <#> will pulled to foreground.

{{% task %}}
Try this for yourself. If the **xeyes** program is not installed, install it first!
{{% /task %}}

#### Pipes

Another option to achieve message sending is through **pipes**. There are two different types of pipes available:

* anonymous pipes
* named pipes

**Anonymous pipes** are like waterslides. You can put some data on it on one end (the top of the slide) and it comes out the other (the bottom), but it's not possible to go up the waterslide from the bottom. Put differently: communication is half-duplex (single direction). One process can **write** into the pipe, while the other can **read** from of the pipe. This type of pipe can only be create between two processes that have parent-child relation ship. What happens internally is that the **stdout** of the first process is mapped to the **stdin** of the second process. For this, we use the `|` (pipe) character.  

When using the CLI, anonymous pipes are a very powerful tool for chaining different commands. The output of the first command will be the input for the next command. This can be chained multiple times.

```bash
jvliegen@localhost:~/$ xeyes &
jvliegen@localhost:~/$ ps -u | grep xeyes | head -1 | cut -d " " -f 3
5526
jvliegen@localhost:~/$ 
```

The example above chains the following:

1. give a list of all *my* processes
2. only filter the lines that contain the word *xeyes* (`grep` stands for Global Regular Expression Print)
3. filter only the first line (`head`)
4. split the input on a space (" ") and report only the third field

Do you remember the Process Control Block ? This has one field called **list of open files**. We've already touched upon stdin, stdout and stderr. Using anonymous pipes will add an entry to this list.

We can also **relink** the 3 default open files to other targets. For example, instead of writing output and errors to the command line, we can redirect them to a file. Similarly, we can read input from a file instead of from the keyboard:

{{% figure src="/img/os/sc_redirect_stdout.png" title="Redirection of the standard output " %}}

The syntax for this is a bit weird though: 1> is meant to redirect data that normally goes to stdout, while 2> is used to relink stderr. You can also point directly to the existing stdout/stderr by using &1 or &2 respectively:

* process 1>{STDOUT} 2>{STDERR}
* process 1>{STDOUT} 2>&1
* process < {STDIN} (read from a file at location {STDIN} rather than from the keyboard)

Note that here we're using the `>` pipe here instead of `|` as above. The difference is subtle, but a simple explanation is that `>` deals with mapping a command to a *file* (or something that pretends to be a file, like stdout/stderr), while `|` maps a command to *another command*. 


**Named pipes** are the other type of pipes that can be created. The main differences with anonymous pipes are the lifetime of this mechanism and their presence in the file system. 

The anonymous pipes above only live for as long as the processes live. Named pipes instead persist and have to be closed explicitly (or are closes automatically at system-shutdown).

Named pipes also have an actual presence in the file system. That is, they show up as files. But unlike most files, they never appear to have contents. Even if you write a lot of data to a named pipe, the file appears to be empty. Making named pipes can be done through the **mkfifo** command.

As they are not frequently used, we leave the interested reader to man page :smiley:.


## Communication between threads

One *raison d'Ãªtre* for multi-threaded applications is **resource sharing**. In the example that was given [earlier](/ch6-tasks/threads/#pthreads) a **global variable** 'counter' was used. No measures were taken for securing this approach it went wrong in that example. The output of the example looks like shown below.

{{% figure src="/img/os/sc_631.png" %}}

This might come as a surprise :smiley: <br/>
It should be clear that what we wanted to see was *Job 1 started* followed by *Job 1 finished* and that this would be repeated again for job number 2.

The first of both threads that gets to its function increments the counter from 0 to 1. However, before this thread has finished its execution, the second thread has started and has incremented the counter from 1 to 2. By the time the first thread finishes, the counter value is 2 in contrast with the intended value of 1.

### Mutex
The simplest form of solving inter-thread communication issues is the use of a mutex. This is a portmanteau of **Mut**ual **Ex**clusion. The behaviour can be seen as the lock on a toilet door. If you are using the toilet, you **lock** the door. Others that want to occupy the toilet have to wait until you're finished and you **unlock** the door (and get out, after washing your hands). Hence, the mutex has only two states: one or zero, on or off, ...

The concept of a mutex is implemented in the pthreads library as a new variable type: **pthread_mutex_t**. Locking and unlocking can be done through functions **pthread_mutex_lock()** and **pthread_mutex_unlock()**. As always, read the documentation for the exact usage of these functions.

The example above can be rewritten using a mutex:

```C
#include <stdio.h>
#include <string.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>

int counter;
pthread_mutex_t lock_counter;                   /* THIS LINE HAS BEEN ADDED */

void* doSomeThing(void *arg) {
    unsigned long i = 0;

    int id;                                     /* THIS LINE HAS BEEN ADDED */
    pthread_mutex_lock(&lock_counter);          /* THIS LINE HAS BEEN ADDED */
    counter += 1;
    id = counter;                               /* THIS LINE HAS BEEN ADDED */
    pthread_mutex_unlock(&lock_counter);        /* THIS LINE HAS BEEN ADDED */


    printf("  Job %d started\n", id);           /* THIS LINE HAS BEEN CHANGED */
    for(i=0; i<(0xFFFFFFFF);i++);
    printf("  Job %d finished\n", id);          /* THIS LINE HAS BEEN CHANGED */

    return NULL;
}

int main(void) {
  int i = 0, err;
  pthread_t tid[2];

  while(i < 2) {
    err = pthread_create(&(tid[i]), NULL, &doSomeThing, NULL);
    if (err != 0) {
      printf("\ncan't create thread :[%s]", strerror(err));
    }
    i++;
  }

  pthread_join(tid[0], NULL);
  pthread_join(tid[1], NULL);

  return 0;
}
```

This solves the issue that was encountered above. Before the counter is accessed the mutex is locked. This provides exclusive access. The counter is then incremented and copied in to variable *id*. Finally, the mutex is unlocked.

With this measure in place, the result is as was intended.
{{% figure src="/img/os/sc_mutex.png" %}}

**PROTIP:** It is pointed out that the time (directionally proportional the number of instructions) between locking and unlocking a mutex should be kept to a minimum. Other threads might be waiting for the mutex to become available.

### Semaphore

A more advance technique for synchronisation, in comparison with a mutex, is a semaphore. To illustrate this, a semaphore can be thought of as a bowl with tokens. For example, in daycare there can be a room with toys. 

{{% figure src="/img/cafe-boulevard.jpg" title="A photo of Cafe Boulevard (courtesy of Tripadvisor)"  width="50%" %}}

Only 5 children are allowed in that room. Outside, there is a bowl with bracelets. When a child wants to enter the room to play, he/she needs to take a bracelet and put it on. When there are not more bracelets, a child that also wants to play in the room has to wait until another child leaves the room and places his/her bracelet back in the bowl.

This technique is used in e.g. producer-consumer problems, amongst many other types. In contrast with the mutex, a semaphore can have multiple states. It is *number* of tokens. It is pointed out that if there is only a single token in the semaphore, this behaves exactly the same as a mutex. Such a semaphore is referred to as a **binary semaphore**.

The **pthreads** library also provides an API to program with semaphores. It contains, amongst others, functions like:

* sem_init(): initialises a semaphore
* sem_wait(): decrements the number inside of the semaphore. 
* sem_post(): increments the number inside of the semaphore.

Note that the ```sem_wait()``` function is blocking. If the value of the semaphore is set to zero, the thread waits until it can acquire a lock. There is a non-blocking alternative sem_trywait(). See the manual pages for more info and the correct usage.


Next to fact that a mutex only has a single token, where a semaphore can have more, the signalling is also a main difference. When a thread wants to get access to a semaphore and there are no more tokens available, it goes into a sleep-like state. When another thread produces a semaphore, a signal is sent to all the threads that were 'sleeping'.


More info on the differences between a semaphore and a mutex are given [here](https://techdifferences.com/difference-between-semaphore-and-mutex.html).