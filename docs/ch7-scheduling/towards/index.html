<!DOCTYPE html>
<html lang="en" class="js csstransforms3d">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Hugo 0.81.0" />
    <meta name="description" content="">


    <link rel="icon" href="../../images/favicon.png" type="image/png">

    <title>7.3: Towards real-world schedulers :: Operating Systems and C</title>

    
    <link href="../../css/nucleus.css?1646090546" rel="stylesheet">
    <link href="../../css/fontawesome-all.min.css?1646090546" rel="stylesheet">
    <link href="../../css/featherlight.min.css?1646090546" rel="stylesheet">
    <link href="../../css/perfect-scrollbar.min.css?1646090546" rel="stylesheet">
    <link href="../../css/auto-complete.css?1646090546" rel="stylesheet">
    <link href="../../css/theme.css?1646090546" rel="stylesheet">
    <link href="../../css/hugo-theme.css?1646090546" rel="stylesheet">
    
    <link href="../../css/theme-kul.css?1646090546" rel="stylesheet">
    
    

    <script src="../../js/jquery-3.3.1.min.js?1646090546"></script>

    <style>
      :root #header + #content > #left > #rlblock_left{
          display:none !important;
      }
      
        :not(pre) > code + span.copy-to-clipboard {
            display: none;
        }
      
    </style>
      <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>

<script>
window.MathJax = {
  chtml: {
    scale: 2,                      
    minScale: .5,                  
    matchFontHeight: true,         
    mtextInheritFont: false,       
    merrorInheritFont: true,       
    mathmlSpacing: false,          
    skipAttributes: {},            
    exFactor: .5,                  
    displayAlign: 'center',        
    displayIndent: '0'             
  }
};
</script>

<script src=../../js/osc.js></script>
  </head>
  <body class="" data-url="../../ch7-scheduling/towards/">
    <nav id="sidebar" class="">



  <div id="header-wrapper">
    <div id="header">
      <a href="https://www.kuleuven.be/kuleuven/" target="_blank">
	<img src="../../img/style/kul.png" alt="KU Leuven" /><br/>
</a>
<a href="https://www.uhasselt.be/" target="_blank">
	<img src="../../img/style/uhasselt.svg" alt="UHasselt" id="uhlogo" />
</a>
    </div>
    
        <div class="searchbox">
    <label for="search-by"><i class="fas fa-search"></i></label>
    <input data-search-input id="search-by" type="search" placeholder="Search...">
    <span data-search-clear=""><i class="fas fa-times"></i></span>
</div>

<script type="text/javascript" src="../../js/lunr.min.js?1646090546"></script>
<script type="text/javascript" src="../../js/auto-complete.js?1646090546"></script>
<script type="text/javascript">
    
        var baseurl = "https:\/\/kuleuven-diepenbeek.github.io\/osc-course\/";
    
</script>
<script type="text/javascript" src="../../js/search.js?1646090546"></script>

    
  </div>
  
    <section id="homelinks">
      <ul>
        <li>
            <a class="padding" href='../../'><i class='fas fa-home'></i> Home</a>
        </li>
      </ul>
    </section>
  

    <div class="highlightable">
    <ul class="topics">

        
          
          




 
  
    
    <li data-nav-id="/ch1-introos/" title="1: Intro in OS" class="dd-item
        
        
        
        ">
      <a href="../../ch1-introos/">
          <i class='fab fa-linux'></i> 1: Intro in OS
          
      </a>
      
      
        <ul>
          
          
          

        
          
            
            




 
  
    
      <li data-nav-id="/ch1-introos/intro-os/" title="1.1: Intro to OS using Linux" class="dd-item ">
        <a href="../../ch1-introos/intro-os/">
        <i class='fas fa-book'></i> 1.1: Intro to OS using Linux
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch1-introos/filesystems/" title="1.2: File systems" class="dd-item ">
        <a href="../../ch1-introos/filesystems/">
        <i class='fab fa-linux'></i> 1.2: File systems
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch1-introos/cli/" title="1.3: Getting your CLI-feet wet" class="dd-item ">
        <a href="../../ch1-introos/cli/">
        <i class='fas fa-vial'></i> 1.3: Getting your CLI-feet wet
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/ch2-c/" title="2: Introduction in C" class="dd-item
        
        
        
        ">
      <a href="../../ch2-c/">
          <i class='far fa-keyboard'></i> 2: Introduction in C
          
      </a>
      
      
        <ul>
          
          
          

        
          
            
            




 
  
    
      <li data-nav-id="/ch2-c/intro/" title="2.1: The C programming language" class="dd-item ">
        <a href="../../ch2-c/intro/">
        <i class='fas fa-book'></i> 2.1: The C programming language
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch2-c/intro-labs/" title="2.2: String Manipulation" class="dd-item ">
        <a href="../../ch2-c/intro-labs/">
        <i class='fas fa-vial'></i> 2.2: String Manipulation
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch2-c/structs/" title="2.3: Creating order: Structures" class="dd-item ">
        <a href="../../ch2-c/structs/">
        <i class='fas fa-book'></i> 2.3: Creating order: Structures
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch2-c/structs-labs/" title="2.4: Structs" class="dd-item ">
        <a href="../../ch2-c/structs-labs/">
        <i class='fas fa-vial'></i> 2.4: Structs
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch2-c/ecosystems/" title="2.5: C Ecosystems" class="dd-item ">
        <a href="../../ch2-c/ecosystems/">
        <i class='fas fa-book'></i> 2.5: C Ecosystems
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch2-c/ecosystems-labs/" title="2.6: Splitting up Code" class="dd-item ">
        <a href="../../ch2-c/ecosystems-labs/">
        <i class='fas fa-vial'></i> 2.6: Splitting up Code
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/ch3-introcpu/" title="3: Introduction in CPU" class="dd-item
        
        
        
        ">
      <a href="../../ch3-introcpu/">
          <i class='fab fa-linux'></i> 3: Introduction in CPU
          
      </a>
      
      
        <ul>
          
          
          

        
          
            
            




 
  
    
      <li data-nav-id="/ch3-introcpu/1_vonneumann/" title="3.1 Von Neumann Architecture" class="dd-item ">
        <a href="../../ch3-introcpu/1_vonneumann/">
        <i class='fab fa-linux'></i> 3.1 Von Neumann Architecture
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch3-introcpu/1_lab_assembly/" title="3.2: Assembly basics" class="dd-item ">
        <a href="../../ch3-introcpu/1_lab_assembly/">
        <i class='fas fa-vial'></i> 3.2: Assembly basics
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch3-introcpu/2_functions/" title="3.3 Functions and The Stack" class="dd-item ">
        <a href="../../ch3-introcpu/2_functions/">
        <i class='fab fa-linux'></i> 3.3 Functions and The Stack
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch3-introcpu/2_lab_stack/" title="3.4: The Stack" class="dd-item ">
        <a href="../../ch3-introcpu/2_lab_stack/">
        <i class='fas fa-vial'></i> 3.4: The Stack
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/ch4-pointers/" title="4: Pointers &amp; Arrays" class="dd-item
        
        
        
        ">
      <a href="../../ch4-pointers/">
          <i class='far fa-keyboard'></i> 4: Pointers &amp; Arrays
          
      </a>
      
      
        <ul>
          
          
          

        
          
            
            




 
  
    
      <li data-nav-id="/ch4-pointers/pointers/" title="4.1: Pointers and arrays" class="dd-item ">
        <a href="../../ch4-pointers/pointers/">
        <i class='far fa-keyboard'></i> 4.1: Pointers and arrays
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch4-pointers/practical-use/" title="4.2: Practical Use of Pointers" class="dd-item ">
        <a href="../../ch4-pointers/practical-use/">
        <i class='far fa-keyboard'></i> 4.2: Practical Use of Pointers
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch4-pointers/lab/" title="4.3: The Ancient Library" class="dd-item ">
        <a href="../../ch4-pointers/lab/">
        <i class='fas fa-vial'></i> 4.3: The Ancient Library
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/ch5-debugging/" title="5: Debugging" class="dd-item
        
        
        
        ">
      <a href="../../ch5-debugging/">
          <i class='far fa-keyboard'></i> 5: Debugging
          
      </a>
      
      
        <ul>
          
          
          

        
          
            
            




 
  
    
      <li data-nav-id="/ch5-debugging/debugging-ide/" title="5.1: The Easy Way: IDEs" class="dd-item ">
        <a href="../../ch5-debugging/debugging-ide/">
        <i class='far fa-keyboard'></i> 5.1: The Easy Way: IDEs
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch5-debugging/testing/" title="5.3: The Middle Way: TDD" class="dd-item ">
        <a href="../../ch5-debugging/testing/">
        <i class='far fa-keyboard'></i> 5.3: The Middle Way: TDD
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch5-debugging/debugging-gdb/" title="5.2: The Hard Way: GDB" class="dd-item ">
        <a href="../../ch5-debugging/debugging-gdb/">
        <i class='fas fa-vial'></i> 5.2: The Hard Way: GDB
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/ch6-tasks/" title="6: Task management" class="dd-item
        
        
        
        ">
      <a href="../../ch6-tasks/">
          <i class='fab fa-linux'></i> 6: Task management
          
      </a>
      
      
        <ul>
          
          
          

        
          
            
            




 
  
    
      <li data-nav-id="/ch6-tasks/processes/" title="6.1: Processes" class="dd-item ">
        <a href="../../ch6-tasks/processes/">
        <i class='fas fa-book'></i> 6.1: Processes
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch6-tasks/lab1_processmgmt/" title="6.2: Processes (lab)" class="dd-item ">
        <a href="../../ch6-tasks/lab1_processmgmt/">
        <i class='fas fa-vial'></i> 6.2: Processes (lab)
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch6-tasks/interprocess/" title="6.3: Inter Process communication" class="dd-item ">
        <a href="../../ch6-tasks/interprocess/">
        <i class='fas fa-book'></i> 6.3: Inter Process communication
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch6-tasks/threads/" title="6.4: Threads" class="dd-item ">
        <a href="../../ch6-tasks/threads/">
        <i class='fas fa-book'></i> 6.4: Threads
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch6-tasks/lab2_threadsmgmt/" title="6.5: Threads (lab)" class="dd-item ">
        <a href="../../ch6-tasks/lab2_threadsmgmt/">
        <i class='fas fa-vial'></i>6.5: Threads (lab)
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch6-tasks/interthread/" title="6.6: Inter Thread communication" class="dd-item ">
        <a href="../../ch6-tasks/interthread/">
        <i class='fas fa-book'></i> 6.6: Inter Thread communication
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch6-tasks/lab3_interthreadcomm/" title="6.7: Inter-Thread communication (lab)" class="dd-item ">
        <a href="../../ch6-tasks/lab3_interthreadcomm/">
        <i class='fas fa-vial'></i> 6.7: Inter-Thread communication (lab)
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/ch7-scheduling/" title="7: CPU scheduling" class="dd-item
        parent
        
        
        ">
      <a href="../../ch7-scheduling/">
          <i class='fab fa-linux'></i> 7: CPU scheduling
          
      </a>
      
      
        <ul>
          
          
          

        
          
            
            




 
  
    
      <li data-nav-id="/ch7-scheduling/algorithms/" title="7.1: Scheduling algorithms" class="dd-item ">
        <a href="../../ch7-scheduling/algorithms/">
        <i class='fas fa-book'></i> 7.1: Scheduling algorithms
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch7-scheduling/lab1_algorithms/" title="7.2: Scheduling algorithms (lab)" class="dd-item ">
        <a href="../../ch7-scheduling/lab1_algorithms/">
        <i class='fas fa-vial'></i> 7.2: Scheduling algorithms (lab)
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch7-scheduling/towards/" title="7.3: Towards real-world schedulers" class="dd-item active">
        <a href="../../ch7-scheduling/towards/">
        <i class='fas fa-book'></i> 7.3: Towards real-world schedulers
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch7-scheduling/lab2_niceguy/" title="7.4: Mr. nice guy(lab)" class="dd-item ">
        <a href="../../ch7-scheduling/lab2_niceguy/">
        <i class='fas fa-vial'></i> 7.4: Mr. nice guy(lab)
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/ch8-stack/" title="8: The Stack &amp; The Heap" class="dd-item
        
        
        
        ">
      <a href="../../ch8-stack/">
          <i class='far fa-keyboard'></i> 8: The Stack &amp; The Heap
          
      </a>
      
      
        <ul>
          
          
          

        
          
            
            




 
  
    
      <li data-nav-id="/ch8-stack/stackvsheap/" title="8.1: The Stack &amp; the Heap" class="dd-item ">
        <a href="../../ch8-stack/stackvsheap/">
        <i class='fas fa-book'></i> 8.1: The Stack &amp; the Heap
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch8-stack/inspection-labs/" title="8.2: Inspecting memory regions" class="dd-item ">
        <a href="../../ch8-stack/inspection-labs/">
        <i class='fas fa-vial'></i> 8.2: Inspecting memory regions
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch8-stack/scope/" title="8.3: Different Scopes in C" class="dd-item ">
        <a href="../../ch8-stack/scope/">
        <i class='fas fa-book'></i> 8.3: Different Scopes in C
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/ch9-memory/" title="9: Memory Management" class="dd-item
        
        
        
        ">
      <a href="../../ch9-memory/">
          <i class='fab fa-linux'></i> 9: Memory Management
          
      </a>
      
      
        <ul>
          
          
          

        
          
            
            




 
  
    
      <li data-nav-id="/ch9-memory/memory/" title="9.1: Memory management" class="dd-item ">
        <a href="../../ch9-memory/memory/">
        <i class='fas fa-book'></i> 9.1: Memory management
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch9-memory/lab1_segfault/" title="9.2: Deliberate Segfaulting" class="dd-item ">
        <a href="../../ch9-memory/lab1_segfault/">
        <i class='fas fa-vial'></i> 9.2: Deliberate Segfaulting
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch9-memory/paging/" title="9.3: Paging" class="dd-item ">
        <a href="../../ch9-memory/paging/">
        <i class='fas fa-book'></i> 9.3: Paging
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/ch9-memory/lab2_browsing/" title="9.4: Simply browsing through pages" class="dd-item ">
        <a href="../../ch9-memory/lab2_browsing/">
        <i class='fas fa-vial'></i> 9.4: Simply browsing through pages
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/chx-cs/" title="X: Capita Selecta" class="dd-item
        
        
        
        ">
      <a href="../../chx-cs/">
          <i class='fab fa-linux'></i> X: Capita Selecta
          
      </a>
      
      
        <ul>
          
          
          

        
          
            
            




 
  
    
      <li data-nav-id="/chx-cs/rtos/" title="X.2: Real-time Operating Systems" class="dd-item ">
        <a href="../../chx-cs/rtos/">
        <i class='fab fa-linux'></i> X.2: Real-time Operating Systems
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/chx-cs/devdrivers/" title="X.3: Device Drivers" class="dd-item ">
        <a href="../../chx-cs/devdrivers/">
        <i class='fab fa-linux'></i> X.3: Device Drivers
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/exercises/" title="A. Assignments" class="dd-item
        
        
        
        ">
      <a href="../../exercises/">
          <i class='fas fa-pencil-alt'></i> A. Assignments
          
      </a>
      
      
        <ul>
          
          
          

        
          
            
            




 
  
    
      <li data-nav-id="/exercises/c-integrated-ex/" title="1. Integrated C exercise" class="dd-item ">
        <a href="../../exercises/c-integrated-ex/">
        <i class='fas fa-pen-square'></i> 1. Integrated C exercise
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/exercises/c-debugging-testing/" title="2. Testing in C(&#43;&#43;)" class="dd-item ">
        <a href="../../exercises/c-debugging-testing/">
        <i class='fas fa-pen-square'></i> 2. Testing in C(&#43;&#43;)
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/exercises/tasks_inter_thread_communication/" title="3. Inter-thread communication" class="dd-item ">
        <a href="../../exercises/tasks_inter_thread_communication/">
        <i class='fas fa-pen-square'></i> 3. Inter-thread communication
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/exercises/scheduler/" title="4. Pseudo scheduler" class="dd-item ">
        <a href="../../exercises/scheduler/">
        <i class='fas fa-pen-square'></i> 4. Pseudo scheduler
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/appendix/" title="B. Appendix" class="dd-item
        
        
        
        ">
      <a href="../../appendix/">
          <i class='fab fa-github'></i> B. Appendix
          
      </a>
      
      
        <ul>
          
          
          

        
          
            
            




 
  
    
      <li data-nav-id="/appendix/lab_ll_rtos/" title="3.3: The Ancient Library (RTOS)" class="dd-item ">
        <a href="../../appendix/lab_ll_rtos/">
        <i class='fas fa-vial'></i> 3.3: The Ancient Library (RTOS)
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/appendix/reading/" title="1. Recommended reading" class="dd-item ">
        <a href="../../appendix/reading/">
        1. Recommended reading
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/appendix/installing/" title="2. Linux Installation Instructions" class="dd-item ">
        <a href="../../appendix/installing/">
        2. Linux Installation Instructions
        
        </a>
    </li>
     
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/appendix/cheat_sheet/" title="Cheat sheet" class="dd-item ">
        <a href="../../appendix/cheat_sheet/">
        Cheat sheet
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
        
    </ul>

    
    
      <section id="shortcuts">
        <h3>More</h3>
        <ul>
          
              <li>
                  <a class="padding" href="https://uhintra03.uhasselt.be/studiegidswww/opleidingsonderdeel.aspx?a=2019&amp;i=4082&amp;n=4&amp;t=01"><i class='fa fa-university'></i> ECTS Sheet</a>
              </li>
          
              <li>
                  <a class="padding" href="https://kuleuven-diepenbeek.github.io/osc-course/TODO"><i class='fa fa-university'></i> Toledo</a>
              </li>
          
        </ul>
      </section>
    

    
    <section id="footer">
      <p>Built with <a href="https://github.com/matcornic/hugo-theme-learn"><i class="fas fa-heart"></i></a> from <a href="https://getgrav.org">Grav</a> and <a href="https://gohugo.io/">Hugo</a></p>

    </section>
  </div>
</nav>




        <section id="body">
        <div id="overlay"></div>
        <div class="padding highlightable">
              
              <div>
                <div id="top-bar">
                
                
                <div id="breadcrumbs" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
                    <span id="sidebar-toggle-span">
                        <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
                          <i class="fas fa-bars"></i>
                        </a>
                    </span>
                  
                  <span id="toc-menu"><i class="fas fa-list-alt"></i></span>
                  
                  <span class="links">
                 
                 
                    
          
          
            
            
          
          
            
            
          
          
            <a href='../../'>Operating Systems and C</a> > <a href='../../ch7-scheduling/'>7: CPU scheduling</a> > 7.3: Towards real-world schedulers
          
        
          
        
          
        
                 
                  </span>
                </div>
                
                    <div class="progress">
    <div class="wrapper">
<nav id="TableOfContents">
  <ul>
    <li><a href="#reponsiveness-vs-efficiency">Reponsiveness vs Efficiency</a>
      <ul>
        <li><a href="#context-switching">Context switching</a></li>
        <li><a href="#io-bound-vs-cpu-bound-tasks">I/O-bound vs CPU-bound tasks</a></li>
        <li><a href="#time-slice-size">Time slice size</a></li>
        <li><a href="#priorities">Priorities</a></li>
        <li><a href="#a-dynamic-solution">A dynamic solution</a></li>
      </ul>
    </li>
    <li><a href="#linux-schedulers">Linux Schedulers</a>
      <ul>
        <li><a href="#on-scheduler">O(n) scheduler</a></li>
        <li><a href="#o1-scheduler">O(1) scheduler</a></li>
        <li><a href="#the-completely-fair-scheduler">The Completely Fair Scheduler</a></li>
        <li><a href="#other-schedulers">Other schedulers</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
</div>

                
              </div>
            </div>
            
        <div id="head-tags">
        
        </div>
        
        <div id="body-inner">
          
            <h1>
              
              7.3: Towards real-world schedulers
            </h1>
          

        


<p>The previously discussed scheduling algorithms are but a select number of a huge amount of imaginable approaches that can be thought of. We have seen that all individual algorithms come with certain challenges that make them difficult for direct use in real-world scenarios. And we haven&rsquo;t even taken into account all variables that are in play in a typical OS!</p>
<p>As such, in this Section, we first look at a few factors that come into play in real systems. We then look at how the naive schedulers we&rsquo;ve already seen can be adapted to deal with these new problems. Finally, we discuss how all of this has been combined in practice in the Linux OS scheduler over time.</p>
<h2 id="reponsiveness-vs-efficiency">Reponsiveness vs Efficiency</h2>
<h3 id="context-switching">Context switching</h3>
<p>As said previously, when a new task is scheduled for execution by the OS, a number of operations need to happen to swap the old task with the new one. In the previous examples, we&rsquo;ve pretended these operations happen instantly, but that&rsquo;s of course not the case.</p>
<p>Say we have 2 user tasks: X and Y. X has already been running for a while on the processor, while Y is in the ready state, waiting for CPU-time. Say that the OS is using a preemptive scheduler (for example a pure Round-Robin algorithm) and decides to give Y some running time. Switching between the tasks involves the following steps:</p>
<p><strong>Step 1</strong></p>
<p>X has be stopped in such a way that it can continue from where it left off the next time it is scheduled. Therefore, a <em>snapshot</em> has to be made: what is the value of the program counter, what are the values in the registers, which address is the stack pointer pointing to, what are the open files, which parts of the heap are filled, &hellip; ? All these values need to be stored. As was discussed in Chapter 6, the OS keeps a PCB (Process Control Block) for every process, which contains the fields necessary to store all these required parameters: <strong>The PCB of X needs to be stored</strong>. The kernel puts this PCB in a list of paused tasks.</p>
<p>Note: something similar happens for Threads (remember there&rsquo;s also a conceptual TCB), but it&rsquo;s more lightweight, since there is more shared state between threads in the same program and so fewer aspects need to be updated.</p>
<p><strong>Step 2</strong></p>
<p>X is removed from the processor.</p>
<p><strong>Step 3</strong></p>
<p>The scheduler uses the RR scheduling algorithm to determine which process is next. Since Y is the only other process, it is selected. The processor searches Y&rsquo;s PCB in its list of paused tasks.</p>
<p><strong>Step 4</strong></p>
<p>Everything that happened to the PCB of X, now needs to be done in the opposite direction with the PCB of Y: <strong>the PCB of Y needs to be restored</strong>. The program counter is read and the next instruction is loaded. The values of the registers are restored. The stack pointer is updated.</p>
<p><strong>Step 5</strong></p>
<p>Y starts to run on the processor.</p>
<p>In the previous Section, we have called this series of actions &ldquo;Dispatching&rdquo;. As such, the  time it takes for the dispatcher to stop one process and start another running is known as the <strong>dispatch latency</strong>. The actions of updating (and restoring) individual PCB&rsquo;s is typically referred to as <strong>a context switch</strong> (though some sources also call the entire process together a context switch).</p>
<p>As you can see, during the dispatch period, the CPU is not actually doing any useful work: it is waiting and/or updating its state so the new task can start running. As such, the act of dispatching a new process is considered 100% overhead, and it <strong>should be avoided as much as possible</strong>. <em>Note: there are also other aspects that make context switches slower, such as the fact that it often means that data in the cache memory is no longer useful. As the cached data belongs to the previous task, the cache needs to be (partially) flushed and updated with data from the new task as well, which again takes time.</em></p>
<p>However, before you get the wrong idea, it&rsquo;s not all that bad. In practice, the dispatch latency is typically in the order of (10) microseconds (say about 1/100th of a millisecond). Still, if we were to switch processes for example each millisecond, we would have a full 1% overhead, which over time definitely adds up (we don&rsquo;t only spend more time context switching, we also do a larger amount of context switches over time). If you recall from the previous section, we introduced the metric CPU efficiency (�<sub>CPU</sub>), which helps make concrete how much overhead actually was introduced.</p>
<p>We can see that we somehow need to <strong>strike a balance</strong> between being CPU efficiency (less overhead) and keeping the system responsive (switching between tasks often enough). This is easy enough in our simple examples with just 3-10 tasks, but modern systems often run hundreds of tasks at the same time.</p>
<p>The concept of the <strong>time slice</strong>, discussed in the previous section on Round-Robin scheduling, can play a large part in this: shorter time slices make things more responsive, but cause more context switches, and vice versa. As such, we want to determine an ideal time slice length, but it&rsquo;s not easy to see how this can be accomplished. In general, we can really only say that the time slice should always be quite a bit larger than the dispatch latency, but that we don&rsquo;t really have an easy way to determine an upper bound.</p>
<h3 id="io-bound-vs-cpu-bound-tasks">I/O-bound vs CPU-bound tasks</h3>
<p>A second aspect that&rsquo;s highly relevant in modern systems is that there are typically two large classes of tasks: <strong>I/O-bound</strong> and <strong>CPU-bound</strong> tasks.</p>
<p>The I/O-bound tasks typically run for only short amounts of time (a few milliseconds) before they already have to wait for an I/O operation. Put differently, these tasks pause themselves (go into the &ldquo;waiting&rdquo; state) often. A good example is a program that&rsquo;s listening for user input (keyboard/mouse). These tasks are thus sometimes also referred to as <strong>interactive</strong> tasks.</p>
<p>The CPU-bound tasks typically do not require outside input and are often computationally heavy. They run for tens of milliseconds (or much more) without ever yielding/waiting themselves. These jobs typically process data in large chunks, and are sometimes called <strong>batch</strong> tasks.</p>
<p>The fact that there are typically few processes that do &ldquo;something in between&rdquo; again makes it difficult to determine a good time slice length. If there are many I/O-bound tasks, shorter timeslices are probably better, as most tasks will pause themselves frequently anyway, and we don&rsquo;t loose much (extra) efficiency for higher responsiveness.</p>
<p>If there are many CPU-bound tasks, longer timeslices are probably better, as processes will typically fill their slices with useful work and we reduce the amount of context switches (and those tasks typically don&rsquo;t need to be very responsive).</p>
<p>Simply using an average time slice that&rsquo;s &ldquo;somewhere in between&rdquo; can produce the worst of both worlds: it lowers the responsiveness in interactive systems, while (needlessly) increasing the amount of context switches during batch processing.</p>
<p>As in the previous subsection, it&rsquo;s unclear how long a time slice should ideally be to deal with both I/O and CPU-bound tasks.</p>
<!-- ### What does it all mean ?

With the examples above, it should be clear that the size of the time quantum has an impact on the CPU efficiency. Be careful, however, that you formulate the correct conclusion. Stating that a larger time slice would **"always"** increases the CPU efficiency is <u>not correct</u>.

Concluding that a system with a lot of IO-intensive tasks is better of with a smaller time slice, and a system with a lot of CPU-intensive tasks is better of with a larger time slice, would be more correct.

If the latter is not the case, the CPU will not only spend a large percentage of time context switching, it will also do a larger amount of those context switches over time. As a rule of thumb it can be assumed that the time for a context switch is (a little) less than 10% of the time slice.  -->
<!-- 
For example, the combination of round-robin scheduling with priorities is a combo that is used in many real-world schedulers.

How could we mix both algorithms ? One takes priority into account while the other one does not. The only parameter that can tweaked in Round Robin is the *time slice*. Let's try to figure out how that plays out ... but first ...

<figure>
    <img src="../../img/sched/ss_dottedline.png"/> 
</figure>


Images like the one above, we've seen a number of times up until now. A question that arises is: **<span style="border-bottom: 2px dotted black">what happens on the dotted line ?<span>**

As was mentioned before the scheduler has two main jobs:

0. Choose the next task task that is allowed on the processor
0. Dispatching: switching tasks that are running on the processor

The algorithms provide the scheduler with an approach to **choose the next task**. The second function a scheduler has is the **dispatching** of the newly chosen task. Let's break it down.

## Dispatching

There are 2 user jobs: X and Y. X is running on the processor while Y is in the ready state, waiting for CPU-time. The scheduler decides that X's time is over an it's Y's turn on the processor.
 -->
<h3 id="time-slice-size">Time slice size</h3>
<p>Let&rsquo;s illustrate this with an example:</p>
<ul>
<li>There are two I/O-bound tasks. Both run for 1ms, in which they update state and then wait/yield for more input.
<ul>
<li>Input becomes available after 4ms of <em>wait</em> time (starts when the task yields)</li>
<li>Both tasks do three rounds of this (wait for input 3 times in total)</li>
</ul>
</li>
<li>There is one CPU-bound task that runs a total of 10ms without yielding</li>
<li>All three tasks start at 0s</li>
<li>The two I/O-bound tasks are higher priority than the CPU-bound task.</li>
<li>Each task gets to complete its full time slice unless it yields by itself.</li>
<li>In this very unrealistic system, the dispatch latency is a full 1ms</li>
</ul>

<div class="ex">
	<div class="inner">
    	<p>Draw schemas of how these tasks would be scheduled in two scenarios: (1) with a time slice of 2ms and (2) a time slice of 5ms.</p>
<p>Indicate clearly each time a task goes into a ready state and don&rsquo;t forget to take into account the high dispatch latency!</p>
<p>For each scenario, calculate the CPU efficiency (the percentage of time that the processor performs actual work: running task time - dispatch latency).
Note that calculating AJWT is less useful here to compare both scenarios, as we have multiple waiting periods!
As such, focus on the AJCT and calculate that for the three tasks as well.</p>
<p>Answer these questions:</p>
<ol>
<li>How many context switches are there in each scenario?</li>
<li>Which scenario is more efficient? Why?</li>
</ol>
<div class="solution" id="div_q721_v2" style="visibility: hidden">
    <figure>
    <a href="../../img/sched/context_switching.png" data-featherlight="image"><img src="../../img/sched/context_switching.png" id="img_q721_v2"></a>
    <figcaption><h4>Comparison between two time slices</h4></figcaption>
    </figure>
</div>
<input value="Toggle solution" type="button" style="margin: 0 auto;" onclick="toggleAnswer('q721_v2', 1)"/>

	</div>
</div>
<!-- 
With the knowledge of the dispatch latency, the size of the time slice can re-visited. We assume the following setting:

* there are 10 IO intensive tasks (T1 - T10), these
  0. do calculations for 1 ms
  0. request IO operation from disk
  0. wait 10 ms before the result is fetched
* there is 1 calculation intensive task (T11)
* context switching takes 1 ms
* all tasks are long-running

### The time slice is 10 ms


<div class="ex">
	<div class="inner">
    	<p>Try to understand the load that is put on the CPU. There is a periodic pattern.</p>
<ol start="0">
<li>Try to <strong>draw</strong> the repeating pattern in this timing diagram</li>
<li>How many <strong>context switches</strong> are there ?</li>
<li>What is the <strong>efficiency</strong> of the CPU ? (Reminder: CPU efficiency (�<sub>CPU</sub>): the percentage that the processor performs actual work.) <strong>Tip</strong>: read the title of this section !!</li>
</ol>
<figure>
  <a href="../../img/sched/ss_ts.png" data-featherlight="image"><img src="../../img/sched/ss_ts.png" id="img_q721"></a>
  <figcaption><h4>Time slice = 10 ms</h4></figcaption>
</figure>
<div class="solution" id="div_q721" style="visibility: hidden">
  <b>Answer:</b><br/>
  <p>
    2. There are 11 context switches.<br/>
    3. &#0951;<sub>CPU</sub> = t<sub>useful</sub> / t<sub>total</sub> = 110 ms / 121 ms = 0.90909 <br/>
      <span style="padding-left: 20px">&nbsp;</span>t<sub>useful</sub> = 10 x t<sub>IO</sub> + 1 x t<sub>CPU</sub> = 10 x 10ms + 1 x 10ms = 110ms<br/>
      <span style="padding-left: 20px">&nbsp;</span>t<sub>total</sub>= t<sub>useful</sub> + t<sub>overhead> = 110 ms + 11 x 1 ms = 121 ms<br/>
  </p>
</div>
<input value="Toggle solution" type="button" style="margin: 0 auto;" onclick="toggleAnswer('q721')"/>

	</div>
</div>

### The time slice is 100 ms

<div class="ex">
	<div class="inner">
    	<p>Try to understand the load that is put on the CPU. There is a periodic pattern.</p>
<ol start="0">
<li>Try to <strong>draw</strong> the repeating pattern in this timing diagram</li>
<li>How many <strong>context switches</strong> are there ?</li>
<li>What is the <strong>efficiency</strong> of the CPU ? (Reminder: CPU efficiency (�<sub>CPU</sub>): the percentage that the processor performs actual work.) <strong>Tip</strong>: read the title of this section !!</li>
</ol>
<figure>
  <a href="../../img/sched/ss_ts.png" data-featherlight="image"><img src="../../img/sched/ss_ts_l.png" id="img_q722"></a>
  <figcaption><h4>Time slice = 100 ms</h4></figcaption>
</figure>
<div class="solution" id="div_q722" style="visibility: hidden">
  <b>Answer:</b><br/>
  <p>
    2. There are 11 context switches.<br/>
    3. &#0951;<sub>CPU</sub> = t<sub>useful</sub> / t<sub>total</sub> = 200 ms / 211 ms = 0.94787 <br/>
      <span style="padding-left: 20px">&nbsp;</span>t<sub>useful</sub> = 10 x t<sub>IO</sub> + 1 x t<sub>CPU</sub> = 10 x 10ms + 1 x 100ms = 200ms<br/>
      <span style="padding-left: 20px">&nbsp;</span>t<sub>total</sub>= t<sub>useful</sub> + t<sub>overhead> = 200 ms + 11 x 1 ms = 211 ms<br/>
  </p>
</div>
<input value="Toggle solution" type="button" style="margin: 0 auto;" onclick="toggleAnswer('q722')"/>

	</div>
</div> -->
<h3 id="priorities">Priorities</h3>
<p>As discussed in the previous Section, a third aspect is that there is typically a need to indicate which processes are more important than others. This is usually done using <strong>priorities</strong>, whereby each task is assigned a number so they can be fully ordered to determine which is most important.</p>
<p>In the simple Priority-based scheduler we&rsquo;ve considered, the priority was mainly used to determine <em>when</em> to start which process, as higher priority processes are selected earlier. However, we&rsquo;ve also seen that this could lead to <strong>starvation</strong> for low-priority tasks, needing some <em>ageing</em> mechanism to correct this.</p>
<p>However, can we not think of another way of enforcing priorities that solves the ageing problem in a more elegant fashion? Up until this point, we&rsquo;ve also been assuming that we want to determine a single time slice length to use for all tasks, independent of how they behave. We&rsquo;ve seen that this is suboptimal in several ways in terms of efficiency vs responsiveness.</p>
<p>So maybe we can solve both ageing and efficiency by moving away from a fixed-length time slice, to using <strong>multiple different time slice lengths, dynamically assigned per priority</strong>?</p>
<p>For example, high priority jobs could get a longer time slice (say 10ms) to make sure they get to do as much work as possible, while lower priority tasks could get less time (say 2ms per burst). We can then <strong>use a simple Round-Robin scheduler</strong> between the different tasks, as the priorities are enforced by the time slice length, rather than by strict execution order. Lower priority processes would get time on the CPU more often than with a direct priority-based scheduler, but in shorter bursts, solving ageing while keeping relative priorities intact.</p>
<p>This seems like a good idea, but we can again question if this will work well in practice. For example, say the high priority tasks in a system are I/O-bound and the low priority tasks are CPU-bound, the proposed system seems to do the exact opposite of what we want (as I/O-bound tasks don&rsquo;t need long time slices, but batch jobs do).</p>
<p>We can see that this line of thinking is an interesting one, but that once again we&rsquo;re not quite there yet with how to practically apply the concept of <strong>modelling priorities as time slice lengths</strong>.</p>
<h3 id="a-dynamic-solution">A dynamic solution</h3>
<p>To summarize: at this point it&rsquo;s clear that we have multiple different requirements of a real world scheduler: it needs to be both responsive and CPU efficient, it needs to support both I/O-bound and CPU-bound tasks in a decent way, and it needs to have support for per-task priorities to allow further tweaking of scheduling logic. As hinted to in the last section, one possible approach for dealing with these issues, is to use a dynamic time slice length.</p>
<p>As such, a generally proposed solution to these issues is the <strong>multi-level feedback queue scheduler</strong>. In this setup, we no longer have a single long list of processes, but instead distribute them across multiple, independent &ldquo;run queues&rdquo;. Each of these queues can then employ their own scheduling logic (for example use FCFS or RR or even priority-based) and determine other parameters such as if the queue is processed cooperatively or preemptively (in which case, the time slice length can also vary). That&rsquo;s the &ldquo;multi-level&rdquo; part.</p>
<p>The &ldquo;feedback&rdquo; part indicates that tasks can move between these separate queues over time (for example as they become more or less important, as they run for longer or shorter bursts, etc.).</p>
<p>We can then see that we also need a sort of top-level scheduler, that determines how the different run queues are processed (for example, queue 2 can only start if queue 1 is empty).</p>
<p><a href="https://en.wikipedia.org/wiki/Multilevel_feedback_queue">One of the first examples of this approach</a> was given by Fernando J. Corbató et al. in 1962. Their setup has three specific goals:</p>
<ol start="0">
<li>Give preference to short jobs.</li>
<li>Give preference to I/O-bound tasks.</li>
<li>Separate processes into categories based on their need for the processor.</li>
</ol>
<p>To achieve these goals, they employ three differen run queues:</p>
<figure>
    <img src="../../img/sched/ss_mlfq.png"/> 
</figure>
<p>When a newly created process is added to the scheduler, it arrives at the back of the <strong>top queue</strong> (8ms). When it is scheduled, there are two options: (a) either it runs the full 8ms or (b) it yields before that. In the case of (b), it&rsquo;s likely that we have a short and/or I/O bound task. As such, when it is done waiting, it is appended at the back of the top queue again.</p>
<p>In the case of (a) however, it&rsquo;s more likely that we have a CPU-bound task. As such, after the 8ms, it is pre-empted and we move it down to the <strong>middle queue</strong> (16ms), where it should get a longer time slice next time it is run. We can see this improves efficiency, as we can assume the task will remain CPU-bound and thus we have only half the context switches for these processes!</p>
<p>If the processes in the middle queue keep running to their full time slice of 16ms multiple times, this is an indication they are very heavily CPU-bound. In response, we move them down to the <strong>bottom queue</strong>. Here, processes are run in FCFS fashion until completion.</p>
<p>Finally, processes can move <em>up</em> to the previous queue if they yield to an I/O operation. This allows for example mostly batch tasks to still get a bit more execution time if they have phases in their programming that requires some I/O work.</p>
<p>Across the three different run queues, a simple FCFS logic is applied: the top queue is processed until it is empty and only then are tasks from the middle queue scheduled. Note: if I/O bound tasks are waiting, they are of course no longer in the top queue, otherwise the bottom queues would never get any time! Only tasks ready to execute are in the queues.</p>

<div class="notices note" ><p>As said in the previous Section, it is difficult to do Shortest Job First (SJF) scheduling, since it&rsquo;s difficult to know the total duration of a job. This type of setup however tries to approximate this logic by looking not at the total duration of a job, but at <strong>the duration of individual &ldquo;bursts&rdquo;</strong>. Longer jobs automatically move down to the lower queues, leaving more room for jobs with shorter bursts at the top.</p>
</div>

<p>The setup described above is of course highly specific to those three goals and needs of a particular system. The concepts of the multi-level feedback queue are however much more flexible, as we can also envision other ways of partioning queues to model other advanced scheduling setups. For example:</p>
<ol start="0">
<li>Each level can represent a separate priority (doing for example RR within each level gives us the simple Priority-based scheduler from the previous Section)</li>
<li>Each level can represent a separate scheduler (the first level can for example do RR, the next FCFS, the next priority-based, etc.)</li>
<li>Each level can represent a different time slice length (the first has slices of 8ms, the next 16ms, etc.)</li>
</ol>
<p>Between the levels, we can then also employ other schedulers than FCFS of course (e.g., a RR scheduler, a priority-based scheduler etc.) to improve the responsiveness of tasks in the lower levels.</p>
<p>In practice, these aspects are often combined in specific ways to get a desired outcome (as with the example above). This outcome depends on the system and intended usage. We will see several options for this in the next Section on Linux schedulers. In some way, most modern OS schedulers are variations on the general multi-level feedback queue scheduling concept.</p>
<!-- ## Advanced schedulers

Now that we've discussed a few more real-world aspects of tasks, it's time to start building towards more complex schedulers. At this point, we also have to start to take into account how we're actually planning to implement the scheduler in practice. Specifically, we need to think about the data structures we use to store the PCBs and how to track for example task prioririties. 

We will first consider a conceptual model of a flexible scheduler

### Run queue - Hey, you there, get in line !!!

Processes that are ready to be scheduled are in the **ready** state. Processes that are waiting for IO are in **waiting** state. All these **queues** need to be maintained and managed. In the chapter on *Pointers*, *linked lists* were discussed. This technique is heavily used for managing these types of queues.

Depending on the strategy that a scheduler follows different queue systems might be more suited. Remember, the scheduler chooses the next task, a preferably as-fast-as-possible.

#### A simple run queue
The simplest type of a run queue would be a FIFO (first-in-first-out). It should be clear that a scheduler that uses a first-come-first-serve algorithm finds a perfect match with this type of run queue.

**When a process is created**, it is simply added to the back of the queue.

<figure>
    <img src="../../img/sched/ss_runqueue_fifo.png"/> 
</figure>


#### Multiple FIFOs
A priority based system might use the exact same scheduling algorithm, with the exception of priorities. A solution could be to use multiple FIFOs: one FIFO for each priority level.

**When a process is created**, it is simply added to the back of the queue that matches the process's priority level.

<figure>
    <img src="../../img/sched/ss_runqueue_multfifo.png"/> 
</figure>


#### Tree

When a more complex algorithms are used in the scheduler, a tree might suit the needs better. Depending on the strategy a tree might be ordered in a certain way. For example, in a **shortest-job-first** algorithm, jobs may be ordered (from **short** to **long**) in the tree from **left** to **right**.

**When a process is created**, calculations have to be done to determine the position in the three of the new process.

<figure>
    <img src="../../img/sched/ss_runqueue_tree.png"/> 
</figure>


### Multi-level feedback queue -->
<h2 id="linux-schedulers">Linux Schedulers</h2>
<p>Now that we&rsquo;ve explored some of the practical issues with real-world scheduling and introduced a basic solution framework, it&rsquo;s time to look at how things are practically done in the Linux OS. This again goes one step beyond the scheduling logic, as we now need to also take into account performance of the implementations and datastructures, as well as the provided API for programmers (for example, how to actually manipulate priorities in practice).</p>
<p>Over time, the Linux kernel has used different schedulers, of which we will discuss three here. Linux kernels with version 2.4 - 2.6 (before 2003) were using the O(n) scheduler, in 2.6 - 2.6.11 (2003-2007) the used scheduler was O(1), and from 2.6.12 (after 2007) onward the Completely Fair Scheduler (CFS) is mainly used. These schedulers are briefly touched upon here. All of these are preemptive schedulers that incorporate priorities, but as we will see, they do this in various different ways.</p>

<div class="notices note" ><p>You might be confused by O(n) and O(1). This &ldquo;Big Oh&rdquo; notation is an often used concept in computer science to indicate the <strong>worst-case performance</strong> (called &ldquo;time complexity&rdquo;) of a program. In general, the factor inside of the O() function should be as small as possible. As such O(1) is optimal (&ldquo;constant time&rdquo;), while O(n) indicates that in the worst-case, the program scales linearly with (in this case) the amount of tasks (n). Exponential setups like O(n*n) and especially O(2^n) are to be avoided. In practice, O(log N) is often the best you can do.</p>
</div>

<h3 id="on-scheduler">O(n) scheduler</h3>
<p>The O(n) scheduler got his name from the fact that choosing a new task has <strong>linear</strong> complexity. This is because this scheduler uses a <strong>single linked list</strong> to store all the tasks. Upon each context switch, the scheduler iterates over all the ready tasks in the list, (re-)calculating what is called a <strong>&ldquo;goodness&rdquo;</strong> value. This value is a combination of various factors, such as task priority and whether the task fully used its allotted time slice in its previous burst. The task with the highest goodness value is chosen to run next.</p>
<figure>
    <img src="../../img/sched/ss_runqueue_fifo.png"/> 
</figure>
<p>This setup combines some of the aspects of the multi-level feedback queue concept, but in a single datastructure. For example, if a task didn&rsquo;t use its entire alotted time slice, it gets half of the remaining time alotted for its next run (somewhat bumping its priority, as the alotted timeslice is taken into account with the goodness value as well). As such, while each task is typically assigned the same time slice length initially, this starts to vary over time.</p>
<p>In practice, this scheduler works, but it has severe issues. Firstly, it is somewhat <strong>unpredictable</strong> (e.g., the time slice could grow unbounded for very short processes, meaning we need additional logic to deal with this). Secondly, and most importantly in practice, the performance was too low. Because each task&rsquo;s goodness needs to be caclculated/checked <em>on every context switch (the O(n))</em>, this adds <strong>large amounts of overhead</strong> if there are many concurrent processes. Thirdly, it also does not scale well to multiple processors: each processor is typically scheduled independently, meaning that for each CPU <strong>a mutex lock</strong> had to be obtained on the single task list to fetch the next candidate.</p>
<h3 id="o1-scheduler">O(1) scheduler</h3>
<p>Given the problems of the previous O(n) scheduler, a new, much more advanced version was introduced. One of its main goals was to reduce the time it takes to identify the next task to run, which can now be done in constant time, expressed as O(1).</p>
<p>To understand how exactly this works, we first need to understand how Linux practically deals with priorities, since the O(1) scheduler is tightly integrated with this.</p>
<p>Linux defines task priority as a value between 0 and 139 (so a total of 140 different priorities). 0 is the highest priority, 139 the lowest (somewhat unintuitively&hellip;). The range 0-99 is reserved for so-called <strong>&ldquo;real time&rdquo; tasks</strong>. In practice, these are kernel-level tasks (as the kernel of course also has internal things to do). These also for example include the concrete I/O operations (for example reading from disk), as other (user-space) (I/O-bound) tasks might be waiting for that. The range between 100 and 139 then is reserved for user-space processes, sometimes called <strong>time sharing</strong> or interactive processes.</p>
<p>However, programmers don&rsquo;t manually assign priorities between 100 and 139. Instead, Linux APIs add an additional abstraction on top called the &ldquo;nice value&rdquo;. These nice values are from the range [-20,19], which maps directly onto the &ldquo;real&rdquo; priorities in [100,139]. When a process is <strong>nicer</strong> to other processes (a higher nice value), it means it doesn&rsquo;t mind giving some of its time to other processes. As such, <strong>a higher nice value means a lower priority</strong> (just like a higher priority number also indicates a lower priority conceptually).</p>

<div class="ex">
	<div class="inner">
    	<p>What should be the default nice value (or priority) that is given to a user process?</p>

	</div>
</div>
<p>The clip below tries to illustrate the effect of the overall priority.

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/Bt-Z_Y5Zl44" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>
</p>
<p>(The code for the examples in the video can be found <a href="https://raw.githubusercontent.com/KULeuven-Diepenbeek/osc-course/master/archive_jo/scheduling/blink.c">here</a>).</p>
<p>The O(1) scheduler creates a new <strong>queue (linked list) for each of these 140 different priority values</strong>. For the real-time tasks (queues 0-99), processes within each priority list are scheduled either FCFS or RR, which can be toggled by the user (look for SCHED_FCFS and SCHED_RR). The user-space tasks (100-139) are typically scheduled RR per priority (SCHED_NORMAL) but they can also be scheduled based on remaining runtime to improve batch processing (SCHED_BATCH). Each priority list is emptied in full before the next priority list is considered. At every context switch (at every time slice), the highest priority list with a runnable task is selected.</p>
<figure>
    <img src="../../img/sched/ss_runqueue_multfifo.png"/> 
</figure>
<p>If we were to use this setup directly, the lower-priority tasks would very often by interrupted by higher-priority ones and we again get the problem of starvation. To prevent the need for manual priority adjustment with ageing, the O(1) scheduler instead uses a clever trick, by introducing a second, parallel datastructure. As such, there are two groups of 140 queues. The first is called the <strong>&ldquo;active&rdquo;</strong> queue, the second the <strong>&ldquo;expired&rdquo;</strong> queue. When a task has consumed its time slice completely (either in 1 run, or by yielding multiple times), it is moved to the corresponding &ldquo;expired&rdquo; queue. This allows all processes in the active queue to get some time. When the active processes are all done, the expired and active lists are swapped and the scheduler can again start with the highest priority processes.</p>
<p>This setup is efficient, because we no longer need to loop through all tasks to find the next one: we just need the first task in the highest priority list! As long as processes are added to the correct priority queue, this can be done in constant time. Some psuedocode to illustrate these aspects can be found below:</p>
<div class="highlight"><pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// pseudocode!!!
</span><span style="color:#75715e">// in reality, the data structures and functions look different!
</span><span style="color:#75715e"></span>
<span style="color:#00a8c8">struct</span> <span style="color:#111">PriorityTask</span> <span style="color:#111">{</span>
    <span style="color:#00a8c8">struct</span> <span style="color:#111">Task</span> <span style="color:#f92672">*</span><span style="color:#111">task</span><span style="color:#111">;</span> <span style="color:#75715e">// for example the PCB
</span><span style="color:#75715e"></span>    <span style="color:#00a8c8">struct</span> <span style="color:#111">PriorityTask</span> <span style="color:#f92672">*</span><span style="color:#111">next</span><span style="color:#111">;</span>
<span style="color:#111">}</span>

<span style="color:#00a8c8">struct</span> <span style="color:#111">PriorityList</span> <span style="color:#111">{</span>
    <span style="color:#00a8c8">struct</span> <span style="color:#111">PriorityTask</span> <span style="color:#f92672">*</span><span style="color:#111">first</span><span style="color:#111">;</span>
    <span style="color:#00a8c8">struct</span> <span style="color:#111">PriorityTask</span> <span style="color:#f92672">*</span><span style="color:#111">last</span><span style="color:#111">;</span>
<span style="color:#111">}</span>

<span style="color:#00a8c8">struct</span> <span style="color:#111">RunQueue</span> <span style="color:#111">{</span>
    <span style="color:#00a8c8">struct</span> <span style="color:#111">PriorityList</span> <span style="color:#f92672">*</span><span style="color:#111">tasks</span><span style="color:#111">[</span><span style="color:#ae81ff">139</span><span style="color:#111">];</span> <span style="color:#75715e">// 140 linked lists, 1 for each priority
</span><span style="color:#75715e"></span><span style="color:#111">}</span>

<span style="color:#00a8c8">void</span> <span style="color:#111">appendToList</span><span style="color:#111">(</span><span style="color:#00a8c8">struct</span> <span style="color:#111">PriorityList</span> <span style="color:#f92672">*</span><span style="color:#111">list</span><span style="color:#111">,</span> <span style="color:#00a8c8">struct</span> <span style="color:#111">Task</span> <span style="color:#f92672">*</span><span style="color:#111">newTask</span><span style="color:#111">)</span> <span style="color:#111">{</span>
    <span style="color:#75715e">// TODO: make sure list-&gt;last exists etc.
</span><span style="color:#75715e"></span>    <span style="color:#111">list</span><span style="color:#f92672">-&gt;</span><span style="color:#111">last</span><span style="color:#f92672">-&gt;</span><span style="color:#111">next</span> <span style="color:#f92672">=</span> <span style="color:#111">newTask</span><span style="color:#111">;</span>
    <span style="color:#111">list</span><span style="color:#f92672">-&gt;</span><span style="color:#111">last</span> <span style="color:#f92672">=</span> <span style="color:#111">newTask</span><span style="color:#111">;</span>
<span style="color:#111">}</span>

<span style="color:#00a8c8">struct</span> <span style="color:#111">RunQueue</span> <span style="color:#f92672">*</span><span style="color:#111">active</span><span style="color:#111">;</span>
<span style="color:#00a8c8">struct</span> <span style="color:#111">RunQueue</span> <span style="color:#f92672">*</span><span style="color:#111">expired</span><span style="color:#111">;</span>

<span style="color:#75715e">// new task is started with priority x
</span><span style="color:#75715e"></span><span style="color:#111">appendToList</span><span style="color:#111">(</span> <span style="color:#111">active</span><span style="color:#f92672">-&gt;</span><span style="color:#111">tasks</span><span style="color:#111">[</span><span style="color:#111">x</span><span style="color:#111">],</span> <span style="color:#111">newTask</span> <span style="color:#111">);</span>

<span style="color:#75715e">// scheduler wants to start a new task
</span><span style="color:#75715e">// loops over &#34;active-&gt;tasks&#34; from 0 to 139, looking for the first non-empty list, with index y
</span><span style="color:#75715e">// Note: in reality, a bitmap is used to prevent the need to loop (see below), keeping things O(1)
</span><span style="color:#75715e"></span><span style="color:#00a8c8">struct</span> <span style="color:#111">PriorityTask</span> <span style="color:#f92672">*</span><span style="color:#111">runTask</span> <span style="color:#f92672">=</span> <span style="color:#111">popFirstFromList</span><span style="color:#111">(</span> <span style="color:#111">active</span><span style="color:#f92672">-&gt;</span><span style="color:#111">tasks</span><span style="color:#111">[</span><span style="color:#111">y</span><span style="color:#111">]</span> <span style="color:#111">);</span>
<span style="color:#111">execute</span><span style="color:#111">(</span> <span style="color:#111">runTask</span><span style="color:#f92672">-&gt;</span><span style="color:#111">task</span><span style="color:#111">,</span> <span style="color:#111">runTask</span><span style="color:#f92672">-&gt;</span><span style="color:#111">task</span><span style="color:#111">.</span><span style="color:#111">timeslice</span> <span style="color:#111">)</span>

<span style="color:#75715e">// task is done running and has consumed its timeslice completely
</span><span style="color:#75715e"></span><span style="color:#111">appendToList</span><span style="color:#111">(</span> <span style="color:#111">expired</span><span style="color:#f92672">-&gt;</span><span style="color:#111">tasks</span><span style="color:#111">[</span><span style="color:#111">x</span><span style="color:#111">],</span> <span style="color:#111">runTask</span> <span style="color:#111">);</span>

<span style="color:#75715e">// OR: task is done running and hasn&#39;t consumed its timeslice yet (waiting state)
</span><span style="color:#75715e"></span><span style="color:#111">runTask</span><span style="color:#f92672">-&gt;</span><span style="color:#111">task</span><span style="color:#111">.</span><span style="color:#111">timeslice</span> <span style="color:#f92672">=</span> <span style="color:#111">leftoverTimeslice</span><span style="color:#111">;</span>
<span style="color:#111">appendToList</span><span style="color:#111">(</span> <span style="color:#111">active</span><span style="color:#f92672">-&gt;</span><span style="color:#111">tasks</span><span style="color:#111">[</span><span style="color:#111">x</span><span style="color:#111">],</span> <span style="color:#111">runTask</span> <span style="color:#111">);</span>

<span style="color:#75715e">// if all lists in &#34;active&#34; are empty (no &#34;y&#34; found): swap both runqueues and start over
</span><span style="color:#75715e"></span><span style="color:#00a8c8">struct</span> <span style="color:#111">RunQueue</span> <span style="color:#f92672">*</span><span style="color:#111">temp</span> <span style="color:#f92672">=</span> <span style="color:#111">active</span><span style="color:#111">;</span>
<span style="color:#111">active</span> <span style="color:#f92672">=</span> <span style="color:#111">expired</span><span style="color:#111">;</span>
<span style="color:#111">expired</span> <span style="color:#f92672">=</span> <span style="color:#111">temp</span><span style="color:#111">;</span>
</code></pre></div>
<div class="ex">
	<div class="inner">
    	<p>How would you implement appendToList and popFirstFromList in practice? What other properties should struct Task have besides &ldquo;timeslice&rdquo;?</p>

	</div>
</div>
<p>As explained in the pseudocode, we also need a clever way of knowning which priority queue still has pending tasks without looping over all of them. This can be cleverly done by using a so-called <strong>bitmap</strong>, where each individual bit of an integer is used as a boolean to indicate if there are tasks for the priority corresponding to that bit. To represent 140 bits, we need about 5 32-bit integers (total of 160 bits). Checking which bits are set can be done very efficiently. See the image below for a schematic representation:</p>
<figure>
    <img src="../../img/sched/o1_bitmap.png"/> 
</figure>
<p>As such, we can see the O(1) scheduler is an excellent example of a complex multi-level feedback queue! It utilizes several queues for the different priorities, using different schedulers per-queue depending on the real-timeness of the task. On top, it has two higher-level queues (active and expired) for which it uses an FCFS scheduler. Conceptually a different time slice could also be employed (e.g., higher priorities get a longer time slice), though this was typically not employed.</p>
<p>This scheduler is however not perfect. In practice, it turns out that I/O-bound or interactive processes could get delayed considerably by longer-running processes, due to the active vs expired setup. This caused the need for a complex set of <strong>heuristics</strong> (basically: educated guesses) that the OS would use to estimate which processes were I/O-bound or interactive. These processes would then receive an internal priority boost (again a form of ageing), while non-interactive processes would get penalized. In practice however, like with the O(n) scheduler, this process was somewhat unstable and error-prone.</p>
<h3 id="the-completely-fair-scheduler">The Completely Fair Scheduler</h3>
<p>The current default scheduler was intended to take a bit of a step back from the relatively complex O(1) scheduler and to make things a bit simpler; as we&rsquo;ll see however, that&rsquo;s simpler for Linux kernel developers, not necessarily for us. The CFS is a relatively complex scheduler, and as such a thorough study on this algorithm falls out of the scope of this course. We will touch upon the main concepts however.</p>
<p>The main insight in the CFS is that <strong>the size of the time slices can be highly dynamic</strong>. Previously, we&rsquo;ve seen that interactive processes for example can get 8ms, while CPU-bound processes could get 16ms. That&rsquo;s already nice, but it doesn&rsquo;t take into account the current load of the system: if there are many different processes waiting, each will still get 8 to 16ms, causing later ones to be significantly delayed.</p>
<p>The CFS solves this problem by calculting the per-task time slice length for a given time period based on the number of ready tasks. Say that N tasks are ready and we want to schedule each of them over the next 100ms (an &ldquo;epoch&rdquo;). Then each task is assigned a time slice of 100ms * 1/N (if we ignore the context switching overhead for a bit). In theory, this gives each task an equal share of the processor, hence the name. As such, if there are fewer tasks active in the system, N will be lower, and the time slices will get larger, and vice versa. Of course, the CFS puts a lower bound on the time slice length (typically 4ms) as otherwise the context switching overhead could become too large.</p>
<p>To determine which task executes first within the next epoch, the CFS keeps track of how much time each task has actually spent on the CPU so far. As such, for I/O-bound processes that yield frequently, this value will be lower than for CPU-bound tasks that always use their full time slice. The scheduler always selects the process that has so far <strong>spent the least amount of time on the CPU</strong>. This automatically makes sure that interactive processes are scheduled frequently enough, but also that CPU-bound processes age correctly.</p>
<p>This timekeeping is done in a quite complex datastructure called a (binary) (self-balancing) <strong>red-black tree</strong>. The details are not important here, but this mainly means that the next task (that has spent the last amount of time on the CPU) is always the most bottom left node in the tree. As such, it can easily be retrieved with low overhead. Similarly, adding new tasks (or moving tasks around) in the tree can be done in O(log N).</p>
<figure>
    <img src="../../img/sched/ss_runqueue_tree.png"/> 
</figure>
<p>The complexity increases even more when we look at how this setup incorporates priorities. As there are no longer explicit per-priority lists like in the O(1) scheduler, the CFS simulates this by shrinking/expanding the time slices of low/high priority processes. This is similar to what we&rsquo;ve discussed above, that time slice durations can be used to emulate priorities. As such, if a high priority process executes for 10ms on the CPU, the timekeeper might only record that it spent 5ms of &ldquo;virtual time&rdquo;. This gives the task a &ldquo;priority boost&rdquo; when the scheduler next goes looking for a new task. The opposite is done for low priority tasks (e.g., 10ms of runtime can become 20ms of &ldquo;virtual time&rdquo;). We can see this is no longer a &ldquo;completely fair&rdquo; scheduler in practice, but it&rsquo;s quite elegant in how it combines interactivity, priorities and time slice lengths in practice.</p>
<!-- Although there are **more differences** with earlier scheduler, albeit not so drastically, a thorough study on this algorithm falls out of the scope of this course. In summary, CFS eliminates the concept of a static time slice. This approach solves several problems in mapping priorities to time slices. CFS solves the problems with a simple algorithm that performs well on interactive workloads such as mobile devices without compromising throughput performance on the largest of servers. -->
<p>For more information on CFS you can read the kernel documentation <a href="https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html">here</a>. For the daredevils &hellip; you can even read (or modify, at your own risk) the kernel C code <a href="https://github.com/torvalds/linux/blob/master/kernel/sched/fair.c">here</a>.</p>
<h3 id="other-schedulers">Other schedulers</h3>
<p>As might be expected, these are not the only schedulers that exist, even within Linux. There a many schedulers available and, certainly, there will be many more to come. Just a small grasp of existing schedulers:</p>
<ul>
<li>Brain F*ck Scheduler (Linux)</li>
<li>Noop Scheduler (Linux)</li>
<li>Task Scheduler 1.0 (Windows)</li>
<li>Task Scheduler 2.0 (Windows)</li>
<li>JobScheduler (iOS)</li>
</ul>

<div class="ex">
	<div class="inner">
    	<p>Look up at least 1 other scheduler (for example one used in Windows) and grasp its main concepts and compare it to how Linux works.</p>

	</div>
</div>
<!-- ## Multi-processor considerations

TODO: 

processor affinity/cache locality, NUMA architecture, per-processor queues or shared queues or hybrids

load balancing issues

Symmetric multiprocessing (SMP) is where each processor is self scheduling --><blockquote>
</blockquote>


<footer class="footline">
	
</footer>

        
        </div>
        

      </div>

    <div id="navigation">
        
        

        
            
            
                
                    
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
            
        

        


	 
	 
		
			<a class="nav nav-prev" href="../../ch7-scheduling/lab1_algorithms/" title="7.2: Scheduling algorithms (lab)"> <i class="fa fa-chevron-left"></i></a>
		
		
			<a class="nav nav-next" href="../../ch7-scheduling/lab2_niceguy/" title="7.4: Mr. nice guy(lab)" style="margin-right: 0px;"><i class="fa fa-chevron-right"></i></a>
		
	
    </div>

    </section>

    <div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
      <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
    </div>
    <script src="../../js/clipboard.min.js?1646090546"></script>
    <script src="../../js/perfect-scrollbar.min.js?1646090546"></script>
    <script src="../../js/perfect-scrollbar.jquery.min.js?1646090546"></script>
    <script src="../../js/jquery.sticky.js?1646090546"></script>
    <script src="../../js/featherlight.min.js?1646090546"></script>
    <script src="../../js/modernizr.custom-3.6.0.js?1646090546"></script>
    <script src="../../js/learn.js?1646090546"></script>
    <script src="../../js/hugo-learn.js?1646090546"></script>
    
        
            <script src="../../mermaid/mermaid.js?1646090546"></script>
        
        <script>
            mermaid.initialize({ startOnLoad: true });
        </script>
    
    

  </body>
</html>

