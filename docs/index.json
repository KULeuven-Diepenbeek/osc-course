[
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/intro/",
	"title": "1.1: The C programming language",
	"tags": [],
	"description": "",
	"content": " The C language is a programming language developed in the \u0026lsquo;70s to make it easier to interface with hardware. C was/is in essence nothing more than a few abstraction layers on top of assembly itself.\nC is an imperative programming language. You will notice this when writing some code yourself: we write instructions as statements. These rules or statements are structured in function and struct types. There is little declarative to it, compared to other higher level languages. C\u0026rsquo;s footprint is quite small, the syntax is concise and easy to learn. Statements always express how to do things, instead of what it is doing. Increasing readability is of course important. We could for instance use #define to give meaning to a few symbols, or write clear function blocks.\nC is primarily being used in embedded system development because it is so closely related to the hardware itself. The UNIX, Windows and OSX kernels are fully written in C. The operating system of your cellphone, smartwatch or handheld all build on top of C. A huge amount of languages such as Java (JVM), Python, Ruby and PHP are first and foremost implemented in C.\nComparison with Java import java.io.IOException; import java.nio.*; class FileReader { @Override public String read(String file) throws IOException { return new String(Files.readAllBytes(Paths.get(file))); } } class Main { public static void main(String[] args) { System.out.println(\u0026#34;reading file: \u0026#34;); System.out.println(new FileReader().read(\u0026#34;sup.txt\u0026#34;)); } } How would one go around doing something like that in C? That will become difficult as C does not have a class system! A lower level implementation could look like this:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; char* read(char* file) { FILE *filePointer = fopen(file, \u0026#34;r\u0026#34;); char *buffer = malloc(255); fgets(buffer, 255, (FILE*) filePointer); fclose(filePointer); return buffer; } int main() { printf(\u0026#34;reading file: \\n\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, read(\u0026#34;sup.txt\u0026#34;)); return 0; } Compile the above with gcc -o fileio fileio.c.  Save some text in a file called \u0026ldquo;sup.txt\u0026rdquo;, and execute the program with ./fileio.  Congratulations on your first compiled C program!\n  There are a lot of problems with this implementation: the buffer length is hardcoded and the memory has not been released. A FileReader Java class that does everything for you simply cannot be created. As you can see it\u0026rsquo;s a lot more low-level work than Java\u0026rsquo;s one-liners like Files.readAllBytes! C does not even have the keyword new. Ouch.\nKey differences between C and a higher level language such as C#:\n C\u0026rsquo;s syntax footprint is small: no private/protected/class/interface/inheritance/bool/string\u0026hellip; No \u0026ldquo;standard\u0026rdquo; libraries. C does NOT have exceptions! It works with interrupts and error codes (return 0). C does NOT have garbage collection: you manage the memory yourself. C does NOT have a virtual machine (JVM, CLR) but gets compiled to native machine code. C code usually is full of pointer variables to manipulate memory directly. C allows for combination-integer-types (unsigned short int) C works with headers (.h) and source (.c) files. An executable file requires two steps: compiling and linking. Linking allows for mixing with assembly.  Basic C Hello World #include \u0026lt;stdio.h\u0026gt; int main() { int nr = 42; printf(\u0026#34;sup? %d\u0026#34;, nr); return 0; } The main() function returns a number that determines whether or not your program was executed successfully (0), else some kind of error code will be returned. printf is a function in the default IO header that we need to include, just like Java\u0026rsquo;s import.\nThe \u0026ldquo;f\u0026rdquo; of printf stands for \u0026ldquo;formatting\u0026rdquo; as you can see in the example. See Formatted output.\nWrite a program that outputs the following:  \u0026ldquo;pi is\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;3.1415\u0026rdquo; Based on the floating-point variable pi with a value of 3.1415. The output should end with a new line and contain a tab.\n  Use functions to structure code Done with function. Blocks such as if, for, while, do are familiar and work just like in other languages:\n#include \u0026lt;stdio.h\u0026gt; void say_something_if_positive(int number) { if(number \u0026gt; 5) { printf(\u0026#34;wow, positive or what? \\n\u0026#34;); for(int i = 1; i \u0026lt;= number; i++) { printf(\u0026#34;%d \u0026#34;, i); } printf(\u0026#34;\\n\u0026#34;); } } int main() { say_something_if_positive(5); return 0; } You cannot overload functions in C, unlike in C++ and Java. That means each function name is unique:\nint yay() { return 1; } int yay() { return 0; } int main() { return yay(); // ?? } Does, depending on the compiler, not compile:\n test.c:5:5: error: redefinition of 'yay' int yay() { ^ test.c:1:5: note: previous definition is here int yay() { ^ 1 error generated.  Primitives and combinational types The C language provides the four basic arithmetic type specifiers:\n char (1 byte) int (4 bytes) float (4 bytes) double (8 bytes)  Together with the modifiers:\n signed (minus and plus signs supported) unsigned (only plus signs, greater range) short (/2 bytes) long (x2 bytes)  The table on Wikipedia lists the permissible combinations to specify a large set of storage size-specific declarations. char is the smallest addressable unit, and long double is the biggest. For instance, unsigned char gives you a range of 0 to 255, while signed char works from -127 to 127.\nActual byte sizes are dependent on the target platform - the amount of bytes given above is usually correct for a 64-BIT machine. This can be retrieved using sizeof(type).\n Strings? What do you mean? Forget it: char[] or a char* pointer is the only possibility. And no, it is not as easy as in Java to handle arrays due to the way they are defined.\n#include \u0026lt;stdio.h\u0026gt;#define SIZE 10  int main() { int arr[SIZE]; for(int i = 0; i \u0026lt; SIZE; i++) { arr[i] = i * 10; } for(int j = 0; j \u0026lt; SIZE; j++) { printf(\u0026#34;array index %d has value %d \\n\u0026#34;, j, arr[j]); } char string[] = \u0026#34;hi there\u0026#34;; printf(\u0026#34;%s\u0026#34;, string); return 0; } C reserves the right amount of memory with string literals you know from Java. The string[] char array does contain 9 characters and not 8! That is because the end of the array is determined by a magical NULL terminator, \\0. That makes it easier to loop through all characters and print them - or just let printf do that for you by formatting using %s.\nHandy string utility functions reside in the header file \u0026lt;string.h\u0026gt; (copying, concatenating, asking for the length, \u0026hellip;) See GNU C: String utils.\nWhat is the result of strcmp(\u0026quot;hello\u0026quot;, \u0026quot;Hello\u0026quot;)?  And of strncmp(\u0026quot;hello, world\u0026quot;, \u0026quot;hello, amazing world!!\u0026quot;, 5)?\n  Hint: man strcmp!\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/",
	"title": "1: Introduction in C",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Introduction to C Chapter 1 handles the following subjects:\n Intro to C: primitives, differences between C/Java Structures, char* as strings, arrays Building C source files C Ecosystems Compiling \u0026amp; cross-compiling Building header/source files Makefiles  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/theory1_arduino/",
	"title": "2.1 Arduino UNO",
	"tags": [],
	"description": "",
	"content": "  \u0026raquo;\u0026nbsp;[Naar de labo opgave](#oef) -- The Arduino UNO is an open-source microcontroller board. It is powered by an off-the-shelf ATMega microcontroller from Microchip  . The datasheet for this family of microcontrollers can be found here  .\n  An Arduino UNO   This datasheet contains a block diagram of the AVR architecture. Nonetheless, most of these components could be found in many other microcontrollers as well. The image should be familiar to students that took up the Elektronische systemen course at KU Leuven. 😄\n  Block diagram of the AVR Architecture    The upper right component that is attached to the 8-bit data bus is the Interrupt Unit. This component is the topic of this chapter. Before diving into the details, another topic is explained first: Timer The ATMega microcontroller on the Arduino has, amonst other components, a dedicated Timer. This timer block consists out of 3 timers: two 8-bit timers and a single 16-bit timer. Through the use of the 16-bot timer, the concept of interrupts is illustrated.   Low Level programming Programming the Arduino UNO can be easily done with the Arduino IDE. This user friendly environment is a very nice entry point for new users of microcontrollers. Future engineers, however, should be able to understand what is going on behind the curtain. After all, magic doesn\u0026rsquo;t exist.\n  The Arduino IDE   Bit manipulations When bare metal programming a microcontroller it is often required to start poking specific bits in a register. A quick background refresh is given first.\n  Endianness and approaches in hardware and software    Binary Everybody agrees that the hexadecimal number 0x41 is binary written as 01000001. This is interpreted as 1 x 26 + 1 x 20 = 64 + 1 = 65. The least-significant bit is in the term: 1 x 20. Endianness When this byte is serialised (eg. in an array or in communcation) the question of \"Which bit do we write first ?\" arises. This is defined as the endianness. Big Endian writes the MSB on the right, while Little Endian writes the LSB on the right. Hardware vs. Software In contrast with the software world, hardware engineers typically start counting from the right (instead of the left). The C code for the assignement above would be: int myvalue[] = {1, 0, 0, 0, 0, 0, 1, 0}; where in VHDL this assignment would be: myvalue Now both 'worlds' see myvalue[0] as '1'.   Let\u0026rsquo;s explore the bit manipulations. First we assign the value 1 to an 8-bit type variable.\nunsigned char x; x = 1; With this line, x holds the number \u0026ldquo;00000001\u0026rdquo;. This means the bytes are represented in Little Endian.\nSetting the sixth bit, might be a bit cumbersome. First the result of 25 has to be calculated. After googling the result, the programmer can write:\nunsigned char x; x = 32; More seasoned C programmers might be inclined to use the shift operator  : \u0026lt;\u0026lt;. This litteraly takes te value 1 (remember: this is represented as 00000001) and shifts this value 5 positions to the left, while inserting 0\u0026rsquo;s on the right ( 00000001 + 00000 =\u0026gt; 00000 + 00100000 =\u0026gt; 00100000).\nunsigned char x; x = (1 \u0026lt;\u0026lt; 5); Next to the shift operator, bitwise operators  are also heavily used for setting and/or clearing certain bits. The logical functions AND (\u0026amp;), OR(|) and NOT(~) can be used as efficient tools for bit fiddling.\n❗️ ❗ 🐉 Beware of the dragons 🐉 ❗ ❗️.\nunsigned char x=0, y=0; ... x = (1 \u0026lt;\u0026lt; 5); y = y | (1 \u0026lt;\u0026lt; 5); ... x = (1 \u0026lt;\u0026lt; 5); y = (1 \u0026lt;\u0026lt; 4); if(x \u0026amp;\u0026amp; y) { printf(\u0026#34;YES\\n\u0026#34;); } else { printf(\u0026#34;NO\\n\u0026#34;); } if(x \u0026amp; y) { printf(\u0026#34;YES\\n\u0026#34;); } else { printf(\u0026#34;NO\\n\u0026#34;); } if(x | y) { printf(\u0026#34;YES\\n\u0026#34;); } else { printf(\u0026#34;NO\\n\u0026#34;); }  What will be the printed output of the C-code above ?  Write a line of C-code that:  sets the 3rd bit to \u0026lsquo;1\u0026rsquo; and all others to \u0026lsquo;0\u0026rsquo; (resulting in \u0026ldquo;00000100\u0026rdquo;) sets the 4th and 5th byte to \u0026lsquo;1\u0026rsquo; and all others to \u0026lsquo;0(resulting in \u0026ldquo;00011000\u0026rdquo;)\u0026rsquo;     Hello hardware, this is software speaking A frequently used way of communication between hardware and software is through memory-mapped registers. Such a register can be read or written by software at a certain address. This register serves as driver (in the hardware sense) for inputs of a specific hardware component.\nWhen a register is written by software and read by (or driving) hardware, such a register is sometimes called a command register (CR). When a register is written (or driven) by hardware and read by the software, such a register is sometimes referred to with a status register (SR).\nGoing through the datasheet  of the microcontroller on the Arduino many CRs can be found. Section 36 summarises these registers on more than 3 pages. An example of a register that serves both as a CR and as a SR for controlling of the Analog-to-Digital Converter is shown below. As can be learned from the datasheet, the MSB of this register is used to enable or disable the hardware ADC through software instructions.\n  Example of a CR in the ATMega microcontroller.   The register above can be accessed from software on address register 0x7A. When the software writes to this register ALL 8 bits are written. This is important to remember to avoid one of the dragons described above.\n Two beating hearts As mentioned above, simply cross compiling for the targeted microcontroller allows for programming the Arduino UNO in C, outside of the Arduino IDE. Here two examples are shown to make a blinking light. The first example is for use through the Arduino IDE, the second example uses plain C in bare metal.\nvoid setup() { pinMode(7, OUTPUT); } void loop() { digitalWrite(7, HIGH); delay(500); digitalWrite(7, LOW); delay(500); } This snippet of C code is wrapped by the IDE into a complete C program. Through the tool chain that is applied a lot of magic happens that hides certain more complex aspects from the programmer. Writing the same program in bare metal C for the Arduino is a bit less aesthetic.\n#include \u0026lt;avr/io.h\u0026gt; #define HEARTBEAT_LED 7  int main(void) { int i, j; /* setup */ DDRD |= (1 \u0026lt;\u0026lt; HEARTBEAT_LED); /*loop*/ for/*ever*/ (;;) { PORTD |= (1 \u0026lt;\u0026lt; HEARTBEAT_LED); for(j=0;j\u0026lt;1600;j++) for(i=0;i\u0026lt;1600;i++) asm(\u0026#34;nop\u0026#34;); PORTD \u0026amp;= ~(1 \u0026lt;\u0026lt; HEARTBEAT_LED); for(j=0;j\u0026lt;1600;j++) for(i=0;i\u0026lt;1600;i++) asm(\u0026#34;nop\u0026#34;); } return 0; } The C-file above can be found in the Virtual Machine as example1.c\n A number of things should be pointed out.\n Addresses and bit positions have to be known up front. these are defined in the io.h header file. If this file would not exist the addresses can be found in the datasheet. The \u0026ldquo;Setup and Loop\u0026rdquo;-function approach can be mimicked, but this is not required. The delay(x) function is missing, but this will be addressed later.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch4-debugging/debugging-ide/",
	"title": "4.1: The Easy Way: IDEs",
	"tags": [],
	"description": "",
	"content": " 1. The easy way: Debugging using an IDE Arguably one of the better integrated C/C++ IDEs out there is CLion, a toolkit from Jetbrains based on the IDEA platform you all know from IntelliJ. It has exactly the same tools and capabilities but is fully geared towards C and C++. Cross-compiling and toolchain setup is also very easy using CLion. The Figure below is a screen capture of CLion showcasing it\u0026rsquo;s integrated unit testing capabilities which we will expand upon in the coming sections.\nA quick glance at the screenshot reveals the following buttons:\n Play: Compile and Run Debug Attach to process Run tests (step through, \u0026hellip;) File management window Gutter with line numbers and possibility to add breakpoints \u0026hellip;  A short live demo of CLion\u0026rsquo;s debugging capabilities is in order here.\n CLion is not free but a 30-day trail is, and as a student you can apply for a one-year license for free using your student e-mail address. Bigger development environments like this are typically used when developing large applications with a lot of source and header files. In this course, we will not be needing that. That is why the usage of a tool like this is not needed for now.\nInstead of relying on visual debug tools like CLion, another \u0026lsquo;hard-core\u0026rsquo; commandline alternative exists for Linux: gdb (The GNU debug tool).\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch5-introos/intro-os/",
	"title": "5.1: Intro to OS using Linux",
	"tags": [],
	"description": "",
	"content": "  In the previous chapter the concept of interrupts was introduced. By using these interrupts it becomes easier to execute multiple tasks on a single processor. However, can you imagine developing a complete office-suite using interrupts ?\nIf more tasks come into play, interrupts will not be the answer to our question. But guess what the answer could be: Operating systems !!!\nThe image below shows the classic picture when introducing OSes. The user never talks directly to hardware (or the OS), but always to the software. This protocol holds for all four levels.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD A[User] B[Software] C[Operating System] D[Hardware] A -- B B -- A B -- C C -- B C -- D D -- C  Giving a single, clear definition of what an operating systems is, is no simple job. The operating is basicaly a layer of software that is responsible for a number of things. Mainly, but certainly not exclusively, these tasks include:\n direct accessing the hardware; hide all the complexity of the computer for the user; garanty that different tasks are isolated and protected (form each other); \u0026hellip;  Different OSes exist for different computing platforms.  Laptops, desktops, and serversOn laptops, desktops, and servers, the most well known operating systems are used. These include: Microsoft\u0026rsquo;s Windows, Linux, and MAC OS. It goes without saying that there are many more operating systems for these platforms, but some/many of them are fairly unknown. These might include: DOS, BeOS, BSD, Unix, Solaris, SunOS, \u0026hellip;        Embedded systemsEmbedded systems come in many flavours, colours and sizes. Typically, these devices are smaller and have fewer features than the laptops and co do. It goes without saying that the OSes that run on embedded systems are different to, or at least ported from, the other OSes. A number of OSes for embedded systems are: Android, FreeRTOS, Symbian, mbedOS, and brickOS. \nWhich operating system is the best ?\n  Types of operating systems The image above showed that the OS places itself between general software and hardware. In the most inner core of an OS resides the kernel. This is the heart of the OS. Depending on the type of the kernel, a typical classification of OSes can be made\n  source: https://en.wikipedia.org/wiki/Monolithic_kernel#/media/File:OS-structure2.svg    Monolithic kernel Microkernel Hybrid kernel  A Monotlithic kernel is a kernel that runs the complete operating system in kernel space. Linux is a example of an OS that uses a Monolithic kernel.\nA Microkernel is a kernel that runs the bare minimum of software in kernel space. FreeRTOS is a example of an OS that uses a Monolithic kernel.\nA Hybrid kernel is a type of kernel that is a combination of the two types above. No surprise there, right ?\nIn the definition the Microkernel it states that it runs the bare minimum of software. Generally this contains the following mechanisms:\n task management: Above it is stated that interrupts (as discussed in the previous chapter) will not scalable and that an OS is required when multiple tasks come into play. The management of these tasks is one of the crucial tasks of an OS inter-process communication: handles what is says: the communication between different processes. More on processes in the next chapter. address space management: the is only one (memory-) world. How this world is shared between tasks is dictated by this mechanism.  These three mechanism form the core task of an OS and will be elaborated on in the remainder of this course.\nSystem calls The area marked in \u0026nbsp;yellow\u0026nbsp; in the figure above is called the user mode. The area marked in \u0026nbsp; red \u0026nbsp; in the figure above is called the kernel mode or the privileged mode. A program in user mode has no direct access to the hardware or to the entire memory space. It is also ran with lower priority on the hardware that programs in kernel mode.\nIt is stated above that the user only communicates with software. When the user, or the software on the user\u0026rsquo;s behalf, needs something from the more privileged world the border between the user mode and kernel mode needs to be crossed. There are special functions that facilitate this: System Calls. A list of all the system calls in a Linux operating system can be found here.\nLinux Linux is a an open source Unix-like OS. Although whole books can be (and probably are) written about definitions such as Unix-like and open source, this is of minor importance in this course. What might be worth pointing out is that Linux is based on the Linux kernel. This kernel was first released in 1991 by the Finn: Linus Torvalds.\nThe Linux kernel almost never comes on its own but is packaged in a distribution (a.k.a. a distro). Such a distro is the collection of various pieces software of software and the linux kernel. There is a large number of Linux distributions available. Which one to pick was (and probably is) the start of multiple cultural wars. My personal 2-cent opinion is to take into consideration what you want to use it for.\n  source: https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg   If the figure above doesn\u0026rsquo;t contain a distribution to your liking you can always DIY it: Linux from scratch. Happy compiling !!\nOne of the aspects in which these distro\u0026rsquo;s differ is the packaging system with which it\u0026rsquo;s distributed. These packaging systems allow you to install/uninstall/\u0026hellip; your software. The people that are making distro\u0026rsquo;s take source code from main software packets and compile them using the distro\u0026rsquo;s dependencies. This is then packaged and made available for package managers to install from. Typical examples of package mangers are:\n   Name Extension Typical distro\u0026rsquo;s     dpkg .deb Debian and Ubuntu a.o.   RPM .rpm Red Hat, Fedora, and CentOS a.o.   packman .pkg.tar.xz Arch Linux, FeLi Linux a.o.    If you search for Bodhi in the image above, you\u0026rsquo;ll learn that Bodhi is based on Ubuntu, which is based on Debian. Therefore APT (Advanced Package Tool) is used.\n  Use apt to see a list of the installed packages in the VM Update the list of packages in the VM Upgrade all packages to the most recently available version Install frozen-bubble in the VM    Got Root ? Most operating system allow for multiple users to share one system. Like in most OS-es linux also has an administrative user, or super-user: root. This privileged user is not to be used when doing day-to-day work. However, you are able to login as a root user and do everything you like as this user. Again: this is strongly discouraged !!\nA better way of approaching your day-to-day work on a Linux system is to use a standard user. Whenever you need a higher privilege-level, you can use sudo. This is a simple tool that allows regular user to execute certain commands as the root-user. The VM with this course is organised in this way.\n  source: xkcd.com   Every user that has a login on a Linux system automatically belongs to a group. Depending on the distribution, this group can have multiple names. On Bodhi a new group is created for every user that bares the same name.\nOn files and such On Linux, almost everything is a file. A file \u0026hellip; is a file. A directory \u0026hellip; is a file. A harddrive \u0026hellip; is a file. A UART port \u0026hellip; is a file. Every file is owned by one user. All other users\u0026rsquo; privileges are based on the access permissions.\n  Access permissions in an example folder   The image above shows the content of a folder example this folder contains: 2 files, 2 directories, a hidden directory, and a hidden file. With hidden is meant that these files are not seen with a normal ls. To see these files the -a options has to be present.\nWith the -l the long listing format is shown (as is seen in the image above). With this, the access permissions are shown in the first 10 characters of each line:   source: somewhere on the Internet, found through Google  \n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/processes/",
	"title": "6.1: Process management",
	"tags": [],
	"description": "",
	"content": " One of the three core tasks of an OS is the management of tasks. These different tasks are all running on the same processor. To make this magic happen some form of management is required.\nWhat\u0026rsquo;s in a process ? By definition, a process is an instance of a program. As was dicussed in the \u0026ldquo;C-portion\u0026rdquo; of this course a basic program can be divided in multiple segments. When source code is compiled into a binary, these segments are fixed.\n text/code: is the machine code in assembly. This section is compiled for one (type of) processor(s). data: is the segment that contains initialised variables. These variables could be global, static, or external. A further distinction can be made between normal initialised variables and constants. This distinction is often referred to with read-only (ro-data) and read-write (rw-data), with the former the part where the constants reside and the latter that of the normal variables. bss: this segment contains the global and static variables that are not initialised. stack: see next chapter heap: see next chapter  Let\u0026rsquo;s put these definitions to the test. A very simple program could be written as follows:\n#include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;hello world !\\n\u0026#34;); return 0; } This program can be compiled with the command below:\njvliegen@localhost:~/$ gcc -o hello hello.c jvliegen@localhost:~/$  On the CLI there is a command size that can be used to examine these segments. The arguments that are available on Linux commands can typically be explored with command \u0026ndash;help or man command (offcourse, command needs to be replaced with the actual command-name).\njvliegen@localhost:~/$ size -B hello text data bss dec hex filename 1516 600 8 2124 84c hello jvliegen@localhost:~/$  This command shows the sizes of the sections that are discussed above. The text, data and bss sections are 1516, 600, and 8 bytes. In total this sums up to 2124 bytes, which can be written hexadecimally as 0x84C.\nOK, this makes sense :)\nRun process ! By the time you\u0026rsquo;re reading this part of the course, running the binary that was compiled above should be a walk in the park.\njvliegen@localhost:~/$ ./hello hello world ! jvliegen@localhost:~/$  When a program is started, an instance of the program is created. This results (among many other things) in an allocation of the instance of the program in the memory. This means that the program is mapped somewhere in the memory space. How this mapping in the memory space is achieved will be discussed in chapter 8.\nNext to mapping an instance of the program in memory space, upon start-up a Process Control Block (PCB) is created.\nProcess Control Block The Process Control Block (PCB) is a representation of the process in the OS. It is created as a task_struct object. Such a PCB is made for every process and the definition of its struct is in the kernel source.\nHOLD ON Linux is an open source OS, so does that mean we should be able to find this struct in the source code ?\nWELL YES Inspecting the sched.h file verifies:\n that we can read the source code that the task_struct is indeed there, that the PCB has a lot of parameters. The definition of the struct starts at line 624 and ends at line 1284 (at the moment of writing this course, Nov 15th 2019). As might be clear from this code (or even from thinking about the number of lines of codes), this struct is rather large. A (very) small subset of the fields in the struct represent:  the process state the process identifier (PID) the process priority CPU scheduling info list of open files memory limits CPU registers program counter   The PCBs of all the processes are contained in a doubly-linked list which is headed by the mother of all processes. This process is called init and has PID 0. The doubly-linked list is commonly known as the process table.\nLet\u0026rsquo;s verify all of the above. We\u0026rsquo;ll adapt the C program so it takes more time to run.\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #define DURATION_IN_MINUTES 2  int main(void) { int i; for(i=0;i\u0026lt;(DURATION_IN_MINUTES*60);i++) { printf(\u0026#34;hello world !\\n\u0026#34;); sleep(1); } return 0; } After starting the program, the PID of the process can be looked for.\njvliegen@localhost:~/$ ./longhello hello world ! hello world ! ...jvliegen@localhost:~/$ ps -u USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND jvliegen 14339 0.0 0.0 30408 5500 pts/3 Ss 09:57 0:00 bash jvliegen 20162 0.0 0.0 4504 804 pts/1 S+ 11:49 0:00 ./longhello jvliegen 20244 3.0 0.0 47232 3616 pts/3 R+ 11:51 0:00 ps -u jvliegen 27675 0.0 0.0 30544 5556 pts/0 Ss+ 08:55 0:00 bash jvliegen 27700 0.2 0.5 207400 96300 pts/0 Sl 08:55 0:30 /usr/local/bin/ jvliegen 29414 0.0 0.0 30412 5504 pts/1 Ss 09:13 0:00 bash ... Through the ps command the PID of the process ./longhello can be found. In the example above it\u0026rsquo;s 20162. While this process is running, there is a folder in the /proc map that has the same name as the PID. There is a lot of metadata on the process that can be consulted here. Also, certain fields in the struct_task are reflected in this folder.\njvliegen@localhost:~/$ ls /proc/20162 attr exe mounts projid_map status autogroup fd mountstats root syscall auxv fdinfo net sched task cgroup gid_map ns schedstat timers clear_refs io numa_maps sessionid timerslack_ns cmdline limits oom_adj setgroups uid_map comm loginuid oom_score smaps wchan coredump_filter map_files oom_score_adj smaps_rollup cpuset maps pagemap stack cwd mem patch_state stat environ mountinfo personality statm jvliegen@localhost:~/$ Don\u0026rsquo;t forget it\u0026rsquo;s there !! It might come in handy someday !! Every process has a PCB that contains metadata about the process.\nProcess state One of the fields in the PCB is the process state. This value can be set to any of these values:\n New The process is being created Ready The process is waiting to be assigned to a processor Running Instructions are being executed Waiting The process is waiting for some event to occur (such as an I/O completion or reception of a signal) Terminated The process has finished execution    The different process states and their transitions    p.dinobook { color: #7E7E7E; font-size: 14px; font-weight: 300; letter-spacing: -1px; padding-top: 0px; margin-top: -20px; text-align: center; }  source: SILBERSCHATZ, A., GALVIN, P.B., and GAGNE, G. Operating System Concepts. 9th ed. Hoboken: Wiley, 2013.\nOpen files list Every process that is created has a list of open files. Even programs that do not work with files have this list, and it not empty. Typically three files are open and these files are:\n standard input (stdin) standard output (stdout) standard error (stderr)  By default, stdin is mapped to the keyboard and both stdout and stderr are mapped to the monitor. These mappings can be altered, however. Redirecting can be done like this:\n process \u0026lt; STDIN 1\u0026gt;STDOUT 2\u0026gt;STDERR process \u0026lt; STDIN 1\u0026gt;STDOUT 2\u0026gt;\u0026amp;1    Redirection of the standard output    Creating processes In Linux there are two typical ways for users to create processes: using fork or using exec. For the record, it is mentioned there is a third option using a system() function but because it is less secure and is less efficient then the other two, it is not discussed here.\nBoth fork and exec create a new process. The fork function copies the PCB of its process to a new PCB. The process that calls the fork() is referred to with the parent process while the new process is the child process. The child process will continue operations on the same line as the parent process. Because of the copying of the PCB, the program counter is also copied !!\nThe exec() function call also starts from copying its own PCB. In contrast with fork(), it then replaces the \u0026lsquo;program\u0026rsquo; (read the text, data, and bss) with a new program and starts executing from (relative) 0.\nIt is mentioned earlier that the first process that is started is the init process. When the complete OS starts, the init process spawns a lot of other processes. There are processes that handle DHCP requests, processes that do logging, and so on. Using the pstree command we can see the processes in a tree, and have a visual representation of which child-parent relations there are between processes.\n  An example of the pstree command. The left image shows the result of Linux on an embedded system. The right image shows the result of Linux running on a laptop   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch7-stack/stackvsheap/",
	"title": "7.1: The Stack &amp; the Heap",
	"tags": [],
	"description": "",
	"content": " The Stack and the Heap Program Memory  Compiled computer programs are divided into different sections, each with their own specific needs and properties. Together, they form the program memory. The following image represents these sections, from bottom to top:   text Read-only, fixed size. Contains executable instructions.   data Can be modified. Contains global or static variables that are initialized, such as static int i = 5;. Global variables are variables that live outside of any function scope, and are accessible everywhere, such as int i = 5; int main() { printf(\"%d\", i); }.   bss Can be modified. Contains uninitialized data, such as static int i;.   heap Dynamically growing. Contains data maintained by malloc() and free(), meaning most pointer variables. The heap is shared by all threads, shared librarys, and dynamically loaded modules in a process.   stack Dynamically growing. Contains automatic variables: variables created when (automatically) entered a function, such as int main() { int i = 5; }.      \u0026nbsp;  The Stack Besides (automatic) variables, a few more important things also live in the stack section of the program. These are the stack pointer (SP) and the \u0026lsquo;program stack\u0026rsquo; itself.\nContrary to initialized pointers, arrays within functions are also bound to the stack, such as char line[512];.\nThe Heap Contrary to arrays, initialized pointers are bound to the heap, such as char* line = malloc(sizeof(char) * 10) - except for pointer values that are being assigned directly with a string constant such as char* line = \u0026quot;hello\u0026quot;;. Freeing the last line would result in the error munmap_chunk(): invalid pointer.\nThe usage of malloc() and such is required if you want to reserve space on the heap. memcpy() from \u0026lt;string.h\u0026gt; makes it possible to copy values from the stack to the heap, without having to reassign every single property. Make sure to reserve space first!\n#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef struct Data { int one; int two; } Data; Data* from_stack() { Data data = { 1, 2 }; Data *heap_data = malloc(sizeof(Data)); memcpy(heap_data, \u0026amp;data, sizeof(Data)); return heap_data; } int main() { Data* heap = from_stack(); printf(\u0026#34;one: %d, two: %d\\n\u0026#34;, heap-\u0026gt;one, heap-\u0026gt;two); } This is called creating a deep copy, while a shallow copy creates a copy of a pointer, still pointing to the same value in memory space.\nWhat happens when you omit malloc() and simply write Data *heap_data = memcpy(heap_data, \u0026amp;data, sizeof(Data));?\n  Inspecting program memory in the OS Unix-like operating systems implement procfs, a special filesystem mapped to /proc, that makes it easy for us to inspect program running program state. You will need the process ID (PID) as it is the subdir name. Interesting files to inspect are:\n /proc/PID/maps, a text file containing information about mapped files and blocks (like heap and stack). /proc/PID/mem, a binary image representing the process\u0026rsquo;s virtual memory, can only be accessed by a ptrace\u0026rsquo;ing process.  We will take a closer look at these during the labs.\nMac OSX Does not have procfs. Instead, you will have to rely on commandline tools such as sysctl to query process information.\nShould I use the stack or the heap? Good question. The answer is obviously both. Use the stack when:\n You do not want to de-allocate variables yourself. You need speed (space is managed efficiently by the CPU).  Use the heap when:\n You require a large amount of space (virtually no memory limit). You don\u0026rsquo;t mind a bit slower access (fragmentation problems can occur). You want to pass on (global) objects between functions. You like managing things yourself.  Memory management Freeing up space In order to create an instance of a structure and return it, you have to allocate memory using malloc() from \u0026lt;stdlib.h\u0026gt; - we now that already. In contrast with higher level languages such as Java, C requires programmes to clean up the allocaed memory themselves! This means calling free() to free up the space for future use. For instance:\nstruct Stuff { int number; }; typedef struct Stuff Stuff; void do_nasty_things() { // ...  Stuff* ugly = malloc(sizeof(Stuff)); ugly-\u0026gt;number = 10; // ... } int main() { do_nasty_things(); // other things } As soon as the method do_nasty_things() ends, ugly is not accessible anymore because it was not returned and there are no other references to it. However, after the function, memory is still reserved for it. To counter memory leaks such as these, you can do a few things:\n Keep things local, by keeping things on the stack. The Stack, for that function, will be cleared after calling it. Change Stuff* to Stuff. Free the pointer space at the end of the function by calling free(ugly).  Since this is a small program that ends after main() statements are executed, it does not matter much. However, programs with a main loop that require a lot of work can also contain memory leaks. If that is the case, leak upon leak will cause the program to take op too much memory and simply freeze.\nDo not make the mistake to free up stack memory, such as in this nice example, from the \u0026lsquo;Top 20 C pointer mistakes\u0026lsquo;:\nint main() { int* p1; int m = 100; // stack var  p1 = \u0026amp;m; // pointer to stack var  free(p1); // BOOM headshot!  return 0; }  a.out(83471,0x7fff7e136000) malloc: *** error for object 0x7fff5a24046c: pointer being freed was not allocated *** set a breakpoint in malloc_error_break to debug Abort trap: 6  Dangling pointers A second mistake could be that things are indeed being freed, but pointers still refer to the freed up space, which is now being rendered invalid. This is called a dangling pointer, and can happen both on the heap (while dereferencing an invalid pointer after freeing up space):\nint *p, *q, *r; p = malloc(8); // ... q = p; // ... free(p); r = malloc(8); // ... something = *q; // aha!  , and on the stack (while dereferencing an invalid pointer after returning an address to a local variable that gets cleaned up because it resides on the stack):\nint *q; void foo() { int a; q = \u0026amp;a; } int main() { foo(); something = *q; // aha! } Garbage Collection - not happening in C\u0026hellip; The above mistakes are easily made if you are used to Java:\nvoid foo() { Animal cow = new Animal(); cow.eat(); // ... } public static void main(String[] args) { foo(); // cow instances are cleaned up for you... } This cleaning process, that automatically frees up space in multiple parts of the allocated memory space, is called garbage collecting.  And it is completely absent in C, so beware!\nWhat happens when the stack and heap collide? That is platform-dependent and will hopefully crash instead of cause all forms of pain. There are a few possibilities:\n Stack \u0026ndash;\u0026gt; heap. The C compiler will silently overwrite the heap datastructure! On modern OS systems, there are guard pages that prevent the stack from growing, resulting in a segmentation fault. Also, modern compilers throw exceptions such as stack overflow if you attempt to go outside the reserved space (= segfault). Heap \u0026ndash;\u0026gt; Stack. The malloc() implementation will notice this and return NULL. It is up to you to do something with that result.  Write a program with an infinite loop that puts stuff on the stack. What is the program output? Do the same with infinite malloc()\u0026rsquo;s. What happens now?\n  Optimizing C code Compiler flags Depending on your compiler and your target platform, the C compiler will try to optimize code by rearranging declarations and possibly even removing lines such as completely unused variables. The GNU and LLVM gcc compilers offer multiple levels of optimization that can be enabled by passing along -O1, -O2, and -O3 flags (O = Optimize). Consider the following code:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;void stuff() { char dingdong[] = \u0026#34;hello? who\u0026#39;s there?\u0026#34;; printf(\u0026#34;doing things\\n\u0026#34;); } int main() { stuff(); } stuff is not doging anything with the char array. Compile with gcc -g -O3 test.c to enable debug output and optimize. When disassembling using lldb (LLVM) or gdb (GNU), we see something like this:\n (lldb) disassemble --name stuff a.out`stuff at test.c:3: a.out[0x100000f30]: pushq %rbp a.out[0x100000f31]: movq %rsp, %rbp a.out[0x100000f34]: leaq 0x4b(%rip), %rdi ; \"doing things\" a.out[0x100000f3b]: popq %rbp a.out[0x100000f3c]: jmp 0x100000f64 ; symbol stub for: puts a.out`main + 4 [inlined] stuff at test.c:12 a.out`main + 4 at test.c:12: a.out[0x100000f54]: leaq 0x2b(%rip), %rdi ; \"doing things\" a.out[0x100000f5b]: callq 0x100000f64 ; symbol stub for: puts a.out[0x100000f60]: xorl %eax, %eax  Where is dingdong? The compiler saw it was not used and removed it. Without the -O3 flag:\n (lldb) disassemble --name stuff a.out`stuff at test.c:3: a.out[0x100000e90]: pushq %rbp a.out[0x100000e91]: movq %rsp, %rbp a.out[0x100000e94]: subq $0x30, %rsp a.out[0x100000e98]: movq 0x171(%rip), %rax ; (void *)0x0000000000000000 a.out[0x100000e9f]: movq (%rax), %rax a.out[0x100000ea2]: movq %rax, -0x8(%rbp) a.out[0x100000ea6]: movq 0xc3(%rip), %rax ; \"hello? who's there?\" a.out[0x100000ead]: movq %rax, -0x20(%rbp) a.out[0x100000eb1]: movq 0xc0(%rip), %rax ; \"ho's there?\" a.out[0x100000eb8]: movq %rax, -0x18(%rbp) a.out[0x100000ebc]: movl 0xbe(%rip), %ecx ; \"re?\" a.out[0x100000ec2]: movl %ecx, -0x10(%rbp) a.out[0x100000ec5]: movl $0x0, -0x24(%rbp) a.out[0x100000ecc]: cmpl $0xa, -0x24(%rbp) a.out[0x100000ed3]: jge 0x100000ef2 ; stuff + 98 at test.c:5 a.out[0x100000ed9]: movslq -0x24(%rbp), %rax a.out[0x100000edd]: movb $0x63, -0x20(%rbp,%rax) a.out[0x100000ee2]: movl -0x24(%rbp), %eax a.out[0x100000ee5]: addl $0x1, %eax a.out[0x100000eea]: movl %eax, -0x24(%rbp) a.out[0x100000eed]: jmp 0x100000ecc ; stuff + 60 at test.c:5 a.out[0x100000ef2]: leaq 0x8b(%rip), %rdi ; \"doing things\\n\" a.out[0x100000ef9]: movb $0x0, %al a.out[0x100000efb]: callq 0x100000f46 ; symbol stub for: printf a.out[0x100000f00]: movq 0x109(%rip), %rdi ; (void *)0x0000000000000000 a.out[0x100000f07]: movq (%rdi), %rdi a.out[0x100000f0a]: cmpq -0x8(%rbp), %rdi a.out[0x100000f0e]: movl %eax, -0x28(%rbp) a.out[0x100000f11]: jne 0x100000f1d ; stuff + 141 at test.c:9 a.out[0x100000f17]: addq $0x30, %rsp a.out[0x100000f1b]: popq %rbp a.out[0x100000f1c]: retq a.out[0x100000f1d]: callq 0x100000f40 ; symbol stub for: __stack_chk_fail  You can fiddle with options and such yourself in godbolt.org.\nInstead of bootstrapping the debugger to inspect disassembly, you can also simply dump the object contents using objdump -D (GNU) or otool -tV (OSX).\n volatile When heavily optimizing, sometimes you do not want the compiler to leave things out. This is especially important on embedded devices with raw pointer access to certain memory mapped spaces. In that case, use the volatile keyword on a variable to tell the compiler to \u0026ldquo;leave this variable alone\u0026rdquo; - do not move it\u0026rsquo;s declaration and do not leave it out. For instance:\nint array[1024]; int main (void) { int x; for (int i = 0; i \u0026lt; 1024; i++) { x = array[i]; } } Does pretty much nothing. Compiling with -O3 results in 2 assembly instructions:\n main: xor eax, eax ret  However, if you want x to be left alone, use volatile int x; and recompile:\n main: mov eax, OFFSET FLAT:array .L2: mov edx, DWORD PTR [rax] add rax, 4 mov DWORD PTR [rsp-4], edx cmp rax, OFFSET FLAT:array+4096 jne .L2 xor eax, eax ret  That\u0026rsquo;s a big difference.\nFunction call order Another part of optimizing code is the determination of function call order. For instance, consider the following statement: x = f() + g() * h(). Which function gets called first?\nThe answer is we do not know. Do not rely on function order to calculate something! Each function should be completely independant. There should not be a global variable manipulated in f() which will then be needed in g() or h(). You can inspect disassembled code for different compilers on https://godbolt.org/. It will differ from platform to platform, and from compiler to compiler (and even from option flag to flag).\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch9-capitaselecta/capita-selecta/",
	"title": "9.1: Capita Selecta",
	"tags": [],
	"description": "",
	"content": " "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/exercises/c-integrated-ex/",
	"title": "1. Integrated C exercise",
	"tags": [],
	"description": "",
	"content": " Download the start project here: c-integrated-start.c.\nThe following functions are given:\n showList() prints the values of a list (no need to modify this) clearList() clears objects and frees memory (no need to modify this) createRandomNode() creates a new object with a random value createListOfItems() creates a list of x random objects main() bootstraps everything.  1. Commandline compiling Create a simplified Makefile which does the following when executing the command make:\n Clean up any left object files Compile the exercise Run the exercise  This file should also be submitted.\n2. Create two lists This program makes a list of 10 objects, instances of the node struct, in a linked list. Each object has a random number as it\u0026rsquo;s value. In this exercise, you have to extend the program such that the list will be split up into two lists: one with objects that have an even value, one with objects that have an uneven value. The objects have to continue to exist, but have to be relinked. It is of paramount importance not to make copies of objects! (Remember pointers?)\n3. Refer to previous objects Extend the structure in such a way that not only a pointer to the next value is available, but also to the previous one. Currently, the structure looks like this:\nstruct node { char value; struct node* next; }; A third variable should be added called previous. Think about which of the above functions you need to modify in order to set the correct values. This is essentially creating a double-linked list instead of a single-linked one.\nChange the main() and showList() functions such that they keep track of and print the TAIL of the list instead of the HEAD, using your newly created variable.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/intro-labs/",
	"title": "1.2: String Manipulation",
	"tags": [],
	"description": "",
	"content": " We are at War! We\u0026rsquo;re at war! The orcs are attacking and are looking very hungry! Look at them! (img src)\n1. String manipulation However, instead of simply killing you, these not so friendly looking beasts target vowels instead of bowels. So when speaking to, they munch and munch, stripping your carefully chosen words of all vowels. How rude. Implement a function called char* munch(char* sentence) that obscures all vowels with an \u0026lsquo;X\u0026rsquo;, and then prints the results. You will also need a int main() function.\nAssume a maximum character length of 100 for the input sentence.\nTips:\n Re-read chapter 1. How do you start writing a program in C? Create one file, create a main function, print something and compile/run to test if it works. Then expand. Will you be using scanf() or fgets() for user input? What is the difference? Look up how to use either functions. You can safely ignore the *. A char array gets converted to a pointer if returned or given as an argument. Remember, in Java, the function signature would simply be char[] munch(char[] sentence) Go through the GNU Coding standards. Methods in C are snake-cased: my_nice_method instead of Java\u0026rsquo;s camelcasing myNiceMethod.   INPUT: 'hello friendly green guys' OUTPUT: 'hXllX frXXndly grXXn gXys'  Start from this blueprint:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; char* munch(char* sentence) { char* response = malloc(sizeof(char) * 100); // TODO eat those vowels!  return response; } int main() { char sentence[100]; // TODO read input  printf(\u0026#34;INPUT: %s\\n\u0026#34;, sentence); printf(\u0026#34;OUTPUT: %s\\n\u0026#34;, munch(sentence)); } The correct use of malloc() will be explained in the coming labs.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/structs/",
	"title": "1.3: Creating order: Structures",
	"tags": [],
	"description": "",
	"content": " Structs The only way to structure data in C is using the struct keyword:\nstruct Person { int age; int gender; // no bool, remember?  char name[100]; // do not forget to add a size } We can use this structure to assign values like this:\nstruct Person jaak; // do not forget \u0026#34;struct\u0026#34; // jaak.name = \u0026#34;Jaak Trekhaak\u0026#34;; - this is too easy - won\u0026#39;t work strcpy(jaak.name, \u0026#34;Jaak Trekhaak\u0026#34;); // include \u0026lt;string.h\u0026gt; for this jaak.age = 80; jaak.gender = 1; Another way of assigning values is defining the values inline using the {}brackets:\nstruct Person jaak = { \u0026#34;Jaak Trekhaak\u0026#34;, // need to be in order of property definition  80, 1 }; The next question is, can we also define functions in a struct? Yes and no. A function pointer makes this possible, but it is not the same such as a member variable of a class in Java. C function pointers, however, can be very usefully used as callback methods:\n#include \u0026lt;stdio.h\u0026gt; struct Person { int age; int (*is_old)(); }; int is_old(struct Person this) { printf(\u0026#34;checking age of person: %d\\n\u0026#34;, this.age); return this.age \u0026gt; 60; } int main() { struct Person jaak; jaak.age = 40; jaak.is_old = \u0026amp;is_old; printf(\u0026#34;is jaak old? %d\\n\u0026#34;, jaak.is_old(jaak)); } It looks a bit weird because there is no such thing as a magical variable named this - that\u0026rsquo;s one argument you have to provide yourself. You can emulate functions as members of a data structure, but as you can see it\u0026rsquo;s going to cost you. The function pointer, or callback method, will be further explained in chapter 2.\nCompile and execute the above code. what happens when you comment out jaak.is_old = \u0026amp;is_old;? Implement another function with signature int scoff_at(struct Person p) that calls people old when they are called \u0026ldquo;Jaak\u0026rdquo;. Look at the previous example on how to expand the struct to add a name property.\n  Extra definitions Creating a person looks awkward: struct Person jaak; - why can\u0026rsquo;t we simply use Person jaak;? That is possible if you define your own types using the keyword typedef. It\u0026rsquo;s also useful to emulate your own string implementation:\ntypedef struct Person Person; typedef char* string; Magic numbers are usually defined on top, in header files, using #define. With some tricks we can emulate booleans in C:\n#define TRUE 1 #define FALSE 0  typedef unsigned short int bool; bool male = TRUE; These #define statements are preprocessor flags. These can be as simple as this example or as complex as switching on different CPU architectures and executing another set of rules depending on the outcome. Macros are expanded just before expanding, see the \u0026ldquo;compiling\u0026rdquo; section below. Intricate examples are visible at Wikipedia.\nTypical C code that you may encounter due to lack of a bool: if (result) {...} where result is an int. This is in no case the same as JavaScripts Truthy / Falsey construction! The number 0 is false. EOF,NULL or \\ 0 all evaluate to a number to use this.\nC\u0026rsquo;s By-Value VS Java\u0026rsquo;s By-Ref In C, everything you pass to functions is passed by value, meaning a copy of the value is created to pass to the called function. This is very important to grap because mistakes are easily made. For instance, by passing the Person struct, we copy it. Any changes made to the struct in the function are done ON THAT COPY:\nvoid happy_birthday(Person person) { person.age++; } int main() { Person jaak; jaak.age = 13; happy_birthday(jaak); printf(\u0026#34;%d\\n\u0026#34;, jaak.age); // HUH? Still 13? } The copy of jaak gets to celebrate, but jaak himself stays 13.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; main{main} happy{happy_birthday} jaak[Person jaak] copy[copy of jaak] jaak -.-|create copy| copy main --|push to main stack| jaak happy --|push to local fn stack| copy  To fix this, we need the use of pointers, as explained in chapter two. In Java, every object is passed by reference, meaning it points to the same value and changes will be persistent. As expected, In Java (and in pretty much any other programming langauge) this is not the case for primitives:\npublic static void increase(int i) { i++; } public static void main(String[] args) { int i = 5; increase(i); System.out.println(\u0026#34;i is \u0026#34; + i); // still 5 } Use of header Files The #include statements ensure the correct inclusion of functions in your program. Large programs consist of multiple C (source) and H (header) files that are glued together with compiling and linking. A header file contains function definitions, the declarations are in the source files:\n// person.h  struct Person { int age; } int is_old(struct Person p); With the following source file:\n// person.c  #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;person.h\u0026#34; int is_old(struct Person p) { return p.age \u0026gt; 60; } int main() { struct Person jaak; jaak.age = 10; return 0; } The main function works as a bootstrapper and is never placed in a header file. Note the difference between brackets \u0026lt;\u0026gt; and brackets \u0026quot;\u0026quot; at include: that is the difference between system includes and own includes (use relative paths!).\nThe reason for splitting this up is that other source files also provide access to is_old() and Person and thus the ability to reuse things.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; A{person.h} --|source| B[person.c] B -- E[definition is_old] A{person.h} --|source| C[facebook.c] C -- F[use struct] A{person.h} --|source| D[twitter.c] D -- G[use struct]  If you create a separate header file and include them into the source files, there is no need to compile or link it separately. That is, gcc code.c still suffices. Only when you split up source code into separate source files, multiple output files will need to be compiled - and linked together (with one main() function present somewhere).\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/lab1_arduino-bm/",
	"title": "2.2: Bare metal Arduino",
	"tags": [],
	"description": "",
	"content": " When the going gets tough, the tough get going. Sometimes you need to drop the mock-up and dive down to bare metal.\n  image source: stackexchange.com   First things first \u0026hellip; a beating heart Compile the code below and flash it on the Arduino, both of which can be done through the Makefile. This code can be found under /home/osc/osc-exercises/ch2_interrupts/example1.c. The required setup on the breadboard should look something like this:\n  #include \u0026lt;avr/io.h\u0026gt; /* PHYSICAL CONNECTIONS */ #define HEARTBEAT_LED 7  int main(void) { int i,j; // set data directions  DDRD |= (1 \u0026lt;\u0026lt; HEARTBEAT_LED) /*loop*/ for/*ever*/ (;;) { PORTD |= (1 \u0026lt;\u0026lt; HEARTBEAT_LED); for(j=0;j\u0026lt;1600;j++) for(i=0;i\u0026lt;1600;i++) asm(\u0026#34;nop\u0026#34;); PORTD \u0026amp;= ~(1 \u0026lt;\u0026lt; HEARTBEAT_LED); for(j=0;j\u0026lt;1600;j++) for(i=0;i\u0026lt;1600;i++) asm(\u0026#34;nop\u0026#34;); } return 0; } To compile these example files, simply use make. The Makefile can also be used to flash the binary to the arduino: make flash t=filename. The filename should be replaced with the actual filename of the binary.\nWhat is happening in this code ? The approach in the C code is not too different from the Arduino IDE approach. The direction bit of the LED is set to output: bit_set(PORTD, HEARTBEAT_LED_BIT); In the Loop function, 4 statements are repeated forever:\n toggle the LED ON, wait for half the period, toggle the LED OFF, wait half the period again.  These pseudo functions are actually macros. These are defined in the file helper.h which is included on the first line of the C-file.\nTry to understand the BIT MANIPULATION FUNCTIONS macros:\n BIT(x) LONGBIT(x) bit_get(p,m) bit_set(p,m) bit_clear(p,m) bit_toggle(p,m) bit_write(c,p,m)    The avr/io.h file makes searching for specific addresses in the memory space superfluous. When taking a closer look in this file, lines 271 and 272 read:\n#elif defined (__AVR_ATmega328P__) # include \u0026lt;avr/iom328p.h\u0026gt;  So the actual included defines come from: avr/iom328p.h. This file contains all the defines to ease the address-to-name mapping.\n Try to find out HOW the selection of the correct file in io.h is done. Make a new program that adds a blinking LED to a different port. Modify the new program so there is a phase shift of 90° between both blinking lights.    Translation micro controller Arduino Unfortunately for us, the mapping between the micro controller ports and the Arduino ports are not one-to-one. The image below summarises these mappings. If you want more insights, check the Arduino UNO schematic.\n  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/",
	"title": "2: Interrupts",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Interrupts, the next step towards multitasking This chapter handles the following subjects: Bare metal, arduino, timers, \u0026hellip;\n2.1: Arduino Uno\n Intro Low level programming Bit manipulations Hello hardware, this is software speaking Two beating hearts  2.2 (lab): Bare metal Arduino\n2.3: The timer\n 16-bit Timer Timer frequency Polling vs Interrupt Configuring the timer with interrupts  2.4: (lab) Launch that rocket !!\n2.5: The internals of interrupts\n The internals  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch4-debugging/debugging-gdb/",
	"title": "4.2: The Hard Way: GDB",
	"tags": [],
	"description": "",
	"content": " 2. The hard way: Command-line debugging using GDB In order to fluently debug binary programs, they have to be compiled with the debug flag, gcc -g. This will add metadata to the binary file that gdb uses when disassembling and setting breakpoints. IDEs automatically add metadata like this when you press the \u0026ldquo;Debug\u0026rdquo; button on them, but since this is a command-line application, we need to do everything ourselves.\n2.1 With debug flags Let\u0026rsquo;s start with a heap-based application we would like to inspect:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;string.h\u0026gt; char password[] = \u0026#34;250382\u0026#34;; int main(int argc, char *argv[]) { int stackvar = 5; char *buf = (char *)malloc(100); char *secret = (char *)malloc(100); strcpy(secret, password); printf(\u0026#34;Crackme! \\n\u0026#34;); printf(\u0026#34;Password? \u0026#34;); scanf(\u0026#34;%s\u0026#34;, buf); if (!strcmp(buf, secret)) { printf(\u0026#34;Password OK :)\\n\u0026#34;); } else { printf(\u0026#34;Invalid Password! %s\\n\u0026#34;, buf); } return 0; } If the source code would not have been supplied, making an estimated guess against the password would take a (very) long time. (We naively assume here that the program has been compiled with debug information enabled).\nCompile using gcc -g hackme.c. Take a look at the filesize - without flag:\n wouter@wouter-Latitude-7490:~/Development$ gcc hackme.c -o hackme.bin \u0026\u0026 ls -la | grep hackme.bin -rwxr-xr-x 1 wouter wouter 8568 Jan 7 19:59 hackme.bin  With flag:\n wouter@wouter-Latitude-7490:~/Development$ gcc hackme.c -g -o hackme.bin \u0026\u0026 ls -la | grep hackme.bin -rwxr-xr-x 1 wouter wouter 11352 Jan 7 19:59 hackme.bin  Star the gdb debugger using gdb [binary]. It will enter the interactive gdb shell, where you can set breakpoints, step through code, and have a chance at inspecting the heap, where we might attempt to figure out what\u0026rsquo;s hidden in there.\nThings you need to know from the GDB debugger:\n r: running the program (main() method execution) c: continue after a breakpoint i: inspect (i r [regname]: inspect register name) start and next: start stepping through the application. b *[addr]: set breakpoint at certain address delete: deletes all breakpoints disassemble [fn]: disassembles functionname (after running) x/[length][format] [address expr]: inspect dynamic memory block (see manual)  Bootstrap gdb and step through the whole application. As soon as the stackvar has been evaluated, try to inspect the memory value using x/d. The address expression could be hexadecimal, or \u0026amp;stackvar.  How could you evaluate a heap variable using the x command? If you have the address, how do you pry out the value on the heap?\n  Do not forget that the expression that is printed out is the one to be evaluated after you enter the \u0026lsquo;next\u0026rsquo; command. You can already inspect the stack variable address but it will contain junk:\n (gdb) start Temporary breakpoint 1 at 0x7d9: file hackme.c, line 11. Starting program: /home/wouter/Development/hackme.bin Temporary breakpoint 1, main (argc=1, argv=0x7fffffffdd68) at hackme.c:11 11 int stack = 5; (gdb) x/d \u0026stack 0x7fffffffdc6c: 21845 (gdb) next 12 char *buf = (char *)malloc(100); (gdb) x/d \u0026stack 0x7fffffffdc6c: 5  Address 0x7fffffffdc6c first contains 21845 - a coincidence that might have another value on your machine.\nBootstrap gdb, disassemble the main function, and set breakpoints after each malloc() call using b *[address]. You can check the return value, stored at the register eax, with i r eax.\n  2.2 Without debug flags Now try to \u0026lsquo;hack\u0026rsquo; the password using gdb without the -g compiler flag. Imagine someone has put up a binary file on the internet and you managed to download it. No source code available, and no debug information compiled in. The gdb tool still works, disassembling still works, but method information is withheld. That means calling start and next will not reveal much-needed information about each statement, and we will have to figure it out ourselves by looking at the disassembly information.\nTry to disassemble again and look at the heap value of our secret. Notice that you will not be able to use something like x [varname] because of the lack of debug information! We will have to rely on breakpoints of address values from the disassembly.\n  Remember to always run the program first before disassembling - otherwise address values will be way too low, and thus incorrect.\nWhen inspecting the return value of eax, gdb returns a relative address for our current program (8 BITS), while we need an absolute one (16 BITS) when using the x command to inspect the heap. Look at the disassembly info to prepend the right bits:\n ---Type  to continue, or q  to quit--- 0x0000555555554844 : mov -0x8(%rbp),%rdx 0x0000555555554848 : mov -0x10(%rbp),%rax 0x000055555555484c : mov %rdx,%rsi ... (gdb) b *0x00005555555547ea Breakpoint 1 at 0x5555555547ea (gdb) r Starting program: /home/wouter/Development/osc-labs/solutions/debugging/a.out Breakpoint 1, 0x00005555555547ea in main () (gdb) i r eax eax 0x55756260 1433756256 (gdb) x 0x55756260 0x55756260: Cannot access memory at address 0x55756260 (gdb) x 0x0000555555756260 0x555555756260: 0x00000000  As you can see, 0x55756260 is an invalid memory address, but based on the disassembly info, we can deduce it is actually 0x0000555555756260 we need to look at.\nThe (still) hard way: DDD, a UI on top of GDB Instead of invoking gdb, one can also employ ddd. This is a crude UI on top of the gdb debugger, with multiple windows where the same commands can be entered as you have learned so far. However, ddd also allows you to visualize heap/stack variables while stepping through the application. The Figure below shows a screen-shot of a debug session of our hackme app using ddd.\nThings to try out:\n View -\u0026gt; Show source Rightclick on a line in source (compile with -g again!) -\u0026gt; Add breakpoint Start/step using the buttons or the commands in the cmdline window. Rightclick in the main window -\u0026gt; Add variables by name to watch (for instance buf and password, as shown)  Take a moment to fiddle with ddd. Try to inspect the same heap variable as the previous exercises, but this time visualize them in the main window. It should be (slightly) easier to accomplish.\n  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch5-introos/lab1_wetfeet/",
	"title": "5.2: Getting your CLI-feet wet",
	"tags": [],
	"description": "",
	"content": " \nGetting your feet wet This \u0026lsquo;lab\u0026rsquo; consists out of a list to small tasks that introduce you to the command-line interface. None of these tasks require exhaustive manual labour. They should all be accomplished by using the commands.\nNavigation  figure out in which folder you are at the moment navigate to the root folder navigate to your home folder, using only 1 command make an alias (man alias) that navigates to your home folder from everywhere within the system  File manipulation  make a folder \u0026ldquo;myVeryOwnFolder\u0026rdquo; navigate into that folder create an empty file: empty.txt create a file: another.txt that contains the text hello world remove the file \u0026ldquo;another.txt\u0026rdquo; move up on folder and remove the entire directory myVeryOwnFolder  Access permissions  create a file with bogus content make this file read-only for everyone remove the file make a folder ToBeDeleted remove the execute rights from this folder for ALL users remove this folder  Various  Navigate to osc-exercises/ch5_os  all these files contain random text one file contains the word \u0026ldquo;bamboozle\u0026rdquo; find out which file contains this word find out the line number on which the word occurs  search the man page for the meaning of \u0026ldquo;-x\u0026rdquo; in the command ls display the current date and time execute three commands, using the enter only once  display the current date and time sleep for 10 seconds display the current date and time   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/lab1_processmgmt/",
	"title": "6.2: Processes",
	"tags": [],
	"description": "",
	"content": "    p.dinobook { color: #7E7E7E; font-size: 14px; font-weight: 300; letter-spacing: -1px; padding-top: 0px; margin-top: -20px; text-align: center; }  source: SILBERSCHATZ, A., GALVIN, P.B., and GAGNE, G. Operating System Concepts. 9th ed. Hoboken: Wiley, 2013.\nCreating and inspecting processes  Write a C-program that prints its own PID on the screen.    An example output    Write a C-program that spawns another process. Both parent and child processes announce their existence (through a printf) and their PIDs.    An example output    Write a C-program that creates 4 child processes  every of the childeren checks which numbes (\u0026lt;10k) are prime every child reports only numbers that are prime, together with its own PID     An example output   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch7-stack/inspection-labs/",
	"title": "7.2: Inspecting memory regions",
	"tags": [],
	"description": "",
	"content": " 1. No malloc, no heap Let\u0026rsquo;s look at memory regions of a process that does not call malloc(). This means we will not use the heap just yet. Compile the following code:\n#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; int main() { getchar(); // breaks process until char input  return 0; } To explore the above example, we will introduce getchar() before ending the main() loop, so the program pauses and gives us a change to look under the hood.\nInspect the memory regions of the above program while running it. Look up the process ID using ps aux and browse through the files using cat in /proc/[procid].\n  Locate the following:\n 7f8122192000-7f8122193000 rw-p 00000000 00:00 0 7fffc566a000-7fffc568b000 rw-p 00000000 00:00 0 [stack] 7fffc577d000-7fffc5780000 r--p 00000000 00:00 0 [vvar] 7fffc5780000-7fffc5782000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]  No [heap] region allocated yet. Let\u0026rsquo;s do the same, but use malloc() to allocate a random block of memory. The return value of the method is a void* that can be printed to show the address of the heap region. Use printf(\u0026quot;%p\u0026quot;, p).\n2. malloc: use heap Extend the above example and allocate dynamic memory. What happens in the /proc files? Can you see how the returned address is inside the heap region?\n  Let us use the program strace to figure out what malloc() exactly does. It should be a system call that asks the Operating System to allocate a certain amount of dynamic memory. But we have yet to figure out which system calls exactly are called. The program strace is used to track system calls and signals. Don\u0026rsquo;t be surprised by the amount of calls a simple program like ours makes! Let us try to find the calls for memory allocation.\nIt is a good idea to printf(\u0026quot;before malloc! \u0026quot;) to make sense of the strace output.\nuse strace ./program. It will output a lot of text, ending with read(0, (that is our getchar() break). Can you find the syscalls we are after?\n   munmap(0x7f88a38dc000, 114791) = 0 brk(NULL) = 0x5644fb34d000 brk(0x5644fb36e000) = 0x5644fb36e000 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0 write(1, \"0x5644fb34d260\\n\", 150x5644fb34d260 ) = 15 fstat(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0 read(0,  Aha, brk! What is that? Use man brk to find out more.\nThe data segment gets expanded by moving the program break pointer up, so the heap is actually an extension of the data segment of the program.\n3. multiple mallocs What happens when we call malloc() multiple times in a row?\nExtend the program by allocating 1024 bytes four times in a row. Inspect the program again using strace. What do you notice?\n  Memory allocation is optimized by avoiding a system call each time. It firsts allocates more than needed that will (hopefully) suffice.\nInstead of calling malloc four times, let\u0026rsquo;s see what happens when we use a loop to see how many times brk is called. More importantly, we will also see that he heap grows \u0026lsquo;upward\u0026rsquo;!\nExtend the program by allocating 1024 bytes in a for loop (Use getchar() before and after the loop) that counts to a random high number. Print \u0026ldquo;loop\u0026rdquo; and \u0026ldquo;end\u0026rdquo; before and after the loop. Inspect again using the trace tool, and also take a look at the maps file in the process folder. After entering a key you can re-inspect everything.\n   Before loop: 556a1a947000-556a1a968000 rw-p 00000000 00:00 0 [heap] After loop: 556a1a947000-556a1aa4f000 rw-p 00000000 00:00 0 [heap]  Converted to decimal: 93914201911296 - 93914200965120 = 946176 bytes used.\nIndeed, the Figure from chapter 7.1 and our findings confirm that the heap grows upwards.\n4. Free Until now the above examples have never taken into consideration the fact that one has to get rid unused space using free(). We will leave it up to you to inspect what happens in /proc.\nFurther Reading  Hack the Virtual Memory: malloc, the heap \u0026amp; the program break  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/theory2_timer/",
	"title": "2.3 The timer",
	"tags": [],
	"description": "",
	"content": " With our sleeves rolled up and dirt all the way up to our elbows, it\u0026rsquo;s time to grab a coffee and do so reading/studying again. In this section interrupts will be introduced through the use of a timer.\nA lot of applications that are built using an Arduino need some sense of time. As mentioned earlier the ATMega has 3 dedicated timers on chip: two 8-bit timers and one 16-bit timer. Through these timers the concept of time can be implemented.\n16-bit Timer One component that is in almost every microcontroller is a Timer/counter. This timer/counter can be used for many things: stopwatch, wave generation, timing, \u0026hellip; The block diagram of the 16-bit timer/counter in the Arduino is shown here. Next to this 16-bit timer/counter there are 2 8-bit timer/counters available. The documentation reports registers like TCNTn and OCnB. The letter n is a placeholder for the number of the timer. In the case of the micro controller on the Arduino, the 16-bit counter results in n = 1.\n  Block Diagram of the 16-bit counter in the Arduino microcontroller   During normal operation the counter simply counts from 0x0 to its maximum value.. The left-side image below shows what happens to the 16-bit value TCNT1. The counter can also be used in a different mode: Clear-timer-on-compare (CTC). In this mode the timer starts again at 0x0000, but only counts to a certain value. When this value is reached, the counter resets and starts over. The right-side image below shows the CTC mode with the cap at 0x7FFF and at 0x3FFF.\n  Value of TCNT during normal operation of the 16-bit counter.      Value of TCNT during clear-timer-on-compare (CTC) operation of the 16-bit counter.     The value to which the timer counts in CTC mode can be set through the register OCR1A: the Output Compare Register of timer 1 named A. As can be seen in the block diagram, there is a comparator in the Timer block that compares TCNT1 and OCR1A. The result of this comparator can be evaluated in the control logic. By configuring the timer this control logic can be altered.\nWhat is the frequency at which the counter reaches its maximum value in normal mode ?\n  Timer frequency To determine the frequency at which the counter operates a quick visit to the datasheet holds the answer. The clkT1 can be generated from an external or internal clock source: clkI/O. This incoming clock goes through a prescaler which can be set by the Clock Select bits (CS12, CS11, and CS10).\n  Clock Distribution (source: Datasheet)      Clock Select bits for prescaler cconfiguration (source: Datasheet)     To introduce a clock, a crystal oscillator  is used. The one on the Arduino UNO board runs at a frequency of 16\u0026rsquo;000\u0026rsquo;000 Hz or 16 MHz. This is frequency at which the CPU is working, often referred to as the clock speed. Given that frequency, and the value of the pre-scaler, clock frequency at which the counter operates can be calculated.\n\\( f_{clk_{T1}} = { f_{clk_{I/O}} \\over prescaler_{T1}} = { 16e6 \\over 2^{10}} = 15'625 Hz \\) Because the counter needs 216 clock ticks to reach its maximum, this maximum will be reached every \\( 2^{16} \\over 15625 \\) = 4.19 s. If a LED were to be toggled every time the counter reaches its maximum, the frequency of the toggling LED would be (2 * 4.19 s)-1 = 0.119 Hz.\n  Value of TCNT during clear-timer-on-compare (CTC) operation of the 16-bit counter.   Polling vs Interrupt Before you put down your coffee to get back to work let\u0026rsquo;s discuss polling first. A nice illustration of polling is shown below.\n   \u0026nbsp;\nOur toddler is polling her father. Another example of polling is shown below. This clip, however, ends with an interrupt.\n   \u0026nbsp;\nWould it not be nice that the CPU could just continue working on something else until a certain event occurs eg. the timer reaching its maximum value ? In the second example (the one with the cartoon), the co-pilot interrupts what the processor was doing.\nAn interrupt is a signal that goes to the processor signalling a certain event. There are two sources for this interrupt: hardware and software. The timer that reaches his maximum count and signals this to the processor is an example of a hardware interrupt. An example for a software interrupt could be an attempt of a division by zero.\nConfiguring the timer with interrupts As can be seen from the block diagram on the top of this page, 4 registers are available for interaction with the software:\n TCNTn: Timer/counter value for counter n OCRnA/OCRn: Output Compare Register A for counter n (also available for B) ICRn: Input Capture Register TCCRnA: Timer/Counter Control Register for counter n  The first three registers (TCNT, OCRA/OCRB, and ICR) are all 16-bit registers. Their functionality is self-explanatory. The Control Register needs more explanation, though. Luckily for us, there is \u0026hellip; the datasheet.\n  Timer/Counter Configuration Register 1 (TCCR1)   The following configuration are given. For other configuration the reader is invited to consult the datasheet for him/herself.\n CS12 | CS11 | CS10 : Clock Select as explained above. Dividing the incoming clock with a 1024-bit prescaler gives configuration: 101. WGM13 | WGM12 | WGM11 | WGM10 : Waveform Generation Mode. This is the formal name for the normal mode or the CTC mode that were discussed above. Normal mode of operation is achieved by setting these bits to: 0000 IC.. : Input Capture (Noise Cancellation and Edge Select) are irrelevant for this mode of operation and can be both set to: 0 COM1.. : What should happen when OCRA or OCRB can be chosen from 4 different options (hence the 2 bits). Both these settings are irrelevant for this mode of operation and can be both set to: 00  In summary, TCCR1A should be set to 0b00000000 (or 0x00) and TCCR1B should be set to 0b00000101 (or 0x05).\nThe settings above configure TIMER/COUNTER 1 to operate like requested, but the interrupts still have to be set. To set this, two different flags need to be enabled. In the final section of this chapter these two flags are elaborated on. For now, it suffices to know there is a general Interrupt Enable and a \u0026lsquo;maskable\u0026rsquo; Interrupt Enable. The former can be set by calling the function sie() the latter should be set through a register: Timer Interrupt Mask Register (TIMSK1).\n  Timer Interrupt Mask Register (TIMSK1)   As can be seen from the image above, there are other Interrupts that can be set. For this example only the final one (Timer Overflow Interrupt Enable) should be set to one. This results in setting TIMSK1 to 0b00000001 (or 0x01).\nFinally, when the interrupt is triggered, something should happen. Otherwise this would be quite useless. When an interrupt occurs, the processor halts whatever it was doing and executes a function. In stead of \u0026ldquo;calling\u0026rdquo; the function ourselves, this function call is done automatically. To be able to distinguish between different interrupt sources, different prefixed function names are available. The next section of this chapter will elaborate on this as well. The function-name that is linked to the TIMER/COUNTER 1 overflowing is: TIMER1_OVF_vect.\nThe example code below puts everything together.\n#include \u0026lt;avr/io.h\u0026gt;#include \u0026lt;avr/interrupt.h\u0026gt; #define HEARTBEAT_LED 7  ISR(TIMER1_OVF_vect) { PORTD ^= (1 \u0026lt;\u0026lt; HEARTBEAT_LED); } int main(void) { /* setup */ DDRD |= (1 \u0026lt;\u0026lt; HEARTBEAT_LED); /* configure TIMER/COUNTER 1 */ TCCR1A = 0x00; TCCR1B = 0x05; /* enable the interrupts */ TIMSK1 = 0x01; sei(); /*loop*/ for/*ever*/ (;;); return 0; } The C-file above can be found in the Virtual Machine as /home/osc/osc-exercises/ch2_interrupts/example2.c\n Compile and run the code above. What is the frequency at which the LED toggles ?\n  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch3-pointers/pointers/",
	"title": "3.1: Pointers and arrays",
	"tags": [],
	"description": "",
	"content": " In the schematic examples below, the following concepts can be explicitly distinguished:\n The name of a variable The value of a variable  And the following implicitly:\n The type of a variable The adres of a variable  The type of a variable determines the amount of memory that is freed up to be able to save the value. The value is either a current value or an address that refers to a different value. Each variable has a unique address. Variables can therefore refer to each other.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[varnamevalue] B{varnameaddress}  This example visualizes the instruction int a = 5:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[a5]  Where the type, int, reserves a few bytes depending on the target platform (sizeof(int)), on a specific address. We can manipulate the address itself - this is essential when working with arrays.\n\u0026ldquo;Compound\u0026rdquo; types C uses a pass-by-value system to pass variables to functions. This means that the value is copied, and that function cannot make changes to the original value. That is something positive: separation of concerns.\nWhen we think of our person example of chapter 1, that struct is therefore always copied. That can be very inefficient, depending on the size of the data! To avoid this, we use a \u0026ldquo;pointer\u0026rdquo;: a reference to the current data. Objects are passed by-reference by default in Java - so in C we have to do something extra for this.\nInstead of is_old(struct Person person) the signature becomes is_old(struct Person * person) (note the added asterik *). We have two options for reading a value here:\n \u0026ldquo;dereferencing\u0026rdquo; the pointer: asking for the real value, behind the reference. Following the arrow where it points towards, so to speak. Ask for members of the pointer using \u0026ldquo;.\u0026rdquo;.  Because in C, the . operator takes precedence over *, we have to add brackets to combine both: (*person).age. It is annoying to constantly have to use brackets, so the creators came up with an alternative, the -\u0026gt; operator: person-\u0026gt;age.\n(*pointervariable).property equals to pointervariable-\u0026gt;property.\n In Java properties are accessed using the dot operator ..\nPointer types A pointer is a \u0026ldquo;changeable\u0026rdquo; reference to a variable. Pointers have their own memory address on the stack and can refer to something else at any time: they are not constant. They are recognizable by * after variable type.\n#include \u0026lt;stdio.h\u0026gt; int main() { int young = 10; int old = 80; int *age = \u0026amp;young; age = \u0026amp;old; printf(\u0026#34;%d\\n\u0026#34;, *age); printf(\u0026#34;%d\\n\u0026#34;, age); } What will be printed in the above example? The first line should be obvious, but the second one\u0026hellip;\n  mermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; A{*age} --|after first assignment| B[young10] A -.- |after second assignment| C[old80]  Notice the use of the \u0026amp; operator, it is the address-of operator to fetch the address of a variable. A pointer points to an address, not to a value (of a variable).\nLook at it this way: I live in streetname, city. When I give you my card, you have a reference to my address. I can hand out cards to more people. The card does not represent my house, but points towards it. If you wish to do so, you can write a different address on the card, eliminating my previous address. From that point on, your card points to a different address, while other cards I dealt out still point to my original address.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; C{my card} --|contains directions to| A[my house] B[your house]  If I want to get the address of your house, I\u0026rsquo;d have to use the address-of operator: \u0026amp;your_house. If I want to get the house itself (physically impossible\u0026hellip;), I\u0026rsquo;d use the dereference operator on the card: *card. This simply follows the arrow where card currently points to.\nSo, what was the output of printf(\u0026quot;%d\\n\u0026quot;, age);? 1389434244! Huh? We are printing the address of the pointer, not the actual value (by following where it points to). Remember, to do that, you have to use the dereference * operator: printf(\u0026quot;%d\u0026quot;, *age);. The compiler hints at this with the following warning:\n warning: format specifies type \u0026lsquo;int\u0026rsquo; but the argument has type \u0026lsquo;int *\u0026rsquo; [-Wformat]\n C\u0026rsquo;s By-Value VS Java\u0026rsquo;s By-Ref - redux Pointers can point to pointers which can point to pointers which can \u0026hellip; Add enough * symbols!\nint val = 10; int *ptr = \u0026amp;val; int **ptr_to_ptr = ptr; int **ptr_to_ptr = \u0026amp;ptr; Why does int **ptr_to_ptr = ptr; generate a compiler error?\n  mermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; A{\"**ptr_to_ptr\"} --|ref| B{\"*ptr\"} B -- |ref| C[val10]  Practical use of the double ** notation would be to relink a pointer to another location. As you know from chapter one, variables in C are passed along by value: even pointer values. This means a copy of a pointer is created whenever calling a function with a pointer. Chaining the actual value is possible by following the address using the dereference operator. But chaining the address itself is only possible with double pointers:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;void increase(int* nr) { (*nr)++; } void reassign(int** nr, int* dest) { *nr = dest; } int main() { int* nr = malloc(sizeof(int)), *nr2 = malloc(sizeof(int)); *nr = 10, *nr2 = 5; increase(nr); printf(\u0026#34;%d\\n\u0026#34;, *nr); // prints 11  reassign(\u0026amp;nr, nr2); printf(\u0026#34;%d\\n\u0026#34;, *nr); // prints 5 } Pointer instantiation Where does a new pointer point to that is not yet instantiated?:\nint *ptr; printf(\u0026#34;%d\u0026#34;, *ptr); // prints -12599900072 Whoops. Always assign \u0026lsquo;nothing\u0026rsquo; to a pointer, using int *ptr = NULL. Note that depending on the C implementation (such as VC++, clang, GNU C), an uninitialized pointer might contain the value 0.\nNULL is a platform dependent (!!) macro that in C refers to zero (0), usually in the form of a void pointer. A void * pointer can refer to any type and is usually used to address low-level memory, as we will see using embedded hardware equipment.\nWhat gets printed in the above example if we assign NULL to *ptr?\n  The definition of a pointer does not prescribe the exact location of the *: int* age is the same asint *age (notice the placement of the stars). Be careful with things like \u0026lsquo;int *age, old_age\u0026rsquo;! The last variable here is an ordinary int, and not a pointer!\nFunction pointers Now things are getting interesting. A pointer can also point to a function. (Remember the datastructure from chapter one?). You will need the same signature definition to do that:\n#include \u0026lt;stdio.h\u0026gt; int increase(int nr) { return nr + 1; } int doublenr(int nr) { return nr * 2; } int main() { int (*op)(int) = \u0026amp;increase; printf(\u0026#34;increase 5: %d\\n\u0026#34;, op(5)); op = \u0026amp;doublenr; printf(\u0026#34;double 5: %d\\n\u0026#34;, op(5)); return 0; } The definition of the op pointer looks a bit strange, but the signature predicts that we will return an int (far left), and that one parameter is needed, also in the form of anint (in brackets). If you fail to do so (for instance, by creating a double doublenr(int nr) function), weird things happen, but the program does not crash:\n Wouters-Air:development jefklak$ gcc test.c \u0026\u0026 ./a.out test.c:15:8: warning: incompatible pointer types assigning to 'int (*)(int)' from 'double (*)(int)' [-Wincompatible-pointer-types] op = \u0026doublenr; ^ ~~~~~~~~~ 1 warning generated. increase 5: 6 double 5: 14  Function pointers can also be given as a parameter, for example with void exec (int (* op) (int)) {. A function can return a function (pointer), for example with int (* choose_op (int mod)) (int) {. The function \u0026ldquo;choose_op\u0026rdquo; expects 1 int parameter and returns a function pointer that refers to a function with 1 int parameter and return value int. To simplify that mess, typedef is usually used:\n#include \u0026lt;stdio.h\u0026gt; typedef int(*func_type)(int); int increase(int nr) { return nr + 1; } int doublenr(int nr) { return nr * 2; } func_type choose_op(int mod) { return mod == 0 ? \u0026amp;increase : \u0026amp;doublenr; } void exec(int (*op)(int)) { printf(\u0026#34;exec: %d\\n\u0026#34;, op(5)); } int main() { exec(choose_op(0)); // print 6  exec(choose_op(1)); // print 10  return 0; } Now you understand how we used the \u0026lsquo;callback function\u0026rsquo; is_old() in the Person struct in chapter 1.\nWatch out for syntax! Remember that symbols such as * en \u0026amp; have different meanings.\n int *p; - * after a type: it\u0026rsquo;s a pointer. p = \u0026amp;i - \u0026amp; used in an expression: address-of operation *p = i - * used in an expression: dereference operation  Ponder on this  What is the difference between char msg[] = \u0026quot;heykes\u0026quot; and char *msg = \u0026quot;heykes\u0026quot;? Clarify your answer with a drawing. Wat is the difference between int a[10][20] and int *b[10]? Can you also say something about memory usage? In which case would you definitely use pointers in C, and in which case would you not? Explain your choice. What happens when I get the address of a stack variable, like \u0026amp;x in section \u0026lsquo;changing values around\u0026rsquo;, but the stack got cleared because the method call was finished?  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch3-pointers/",
	"title": "3: Pointers &amp; Arrays",
	"tags": [],
	"description": "",
	"content": " Chapter 3 Pointers and Arrays Chapter 3 handles the following subjects:\n Arrays in C Pointers in C: arrays don\u0026rsquo;t exist! By-reference, By-value malloc(), free() Function pointers Practical examples of pointers:  Aritmetics Linked Lists Swapping Values   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch4-debugging/testing/",
	"title": "4.3: The Middle Way: TDD",
	"tags": [],
	"description": "",
	"content": " Test-Driven Development: Google Test A concept you learned to love in the Software Engineering Skills course.\nIt\u0026rsquo;s concepts and definitions will not be repeated here, but we will introduce Google Test, a unit testing framework for C/C++ that enables us to write tests to track down bugs and reduce the amount of time needed dabbling in gdb. That is one of the major advantages of using automated test frameworks.\nGoogle Test is a C++ (11) framework, not a C framework! We will be using g++ instead of gcc to compile everything. C++ files are suffixed with .cpp instead of .c. Major differences between both languages exist but will not be needed to know all about in order to write a few simple tests.\n A. Installation Most open source libraries require you to download the source code and compile it yourself. For Google Test, we will do exactly that, since we are learning how to work with compiling and making things anyway. We want to only compile googletest, and not googlemock - both are part of the same repository.\n Clone the github repository: https://github.com/google/googletest/tree/v1.10.x. cd googletest Create a builddir and navigate into it: mkdir build, cd build Build Makefiles using cmake: cmake ./../ Build binaries using make: make.  If all goes according to plan, two libraries will have been created:\n libgtest.a ligbtest_main.a  B. Usage Using the library is a matter of doing two things:\n1. Adding include folders You will need a main() function to bootstrap the framework:\n// main.cpp #include \u0026#34;gtest/gtest.h\u0026#34; int main(int argc, char *argv[]) { ::testing::InitGoogleTest(\u0026amp;argc, argv); return RUN_ALL_TESTS(); } And another file where our tests reside:\n// test.cpp #include \u0026#34;gtest/gtest.h\u0026#34; int add(int one, int two) { return one + two; } TEST(AddTest, ShouldAddOneAndTo) { EXPECT_EQ(add(1, 2), 5); } TEST(AddTest, ShouldAlsoBeAbleToAddNegativeValues) { EXPECT_EQ(add(-1, -1), -2); } What\u0026rsquo;s important here is the include that refers to a gtest/gtest.h file. The gtest directory resides in the include folder of your google test installation directory. That means somehow we have to educate the compiler on where to look for the includes!\nThe -I[directory] (I = include) flag is used to tell g++ where to look for includes.\n 2. Linking with the compiled libraries When running the binary main() method, Google Test will output a report of which test passed and which test failed:\n Wouters-MacBook-Air:unittest wgroenev$ ./cmake-build-debug/unittest [==========] Running 2 tests from 2 test cases. [----------] Global test environment set-up. [----------] 1 test from SuiteName [ RUN ] SuiteName.TrueIsTrue [ OK ] SuiteName.TrueIsTrue (0 ms) [----------] 1 test from SuiteName (0 ms total) [----------] 1 test from AddTest [ RUN ] AddTest.ShouldAddOneAndTo /Users/wgroenev/CLionProjects/unittest/test.cpp:18: Failure Expected: add(1, 2) Which is: 3 To be equal to: 5 [ FAILED ] AddTest.ShouldAddOneAndTo (0 ms) [----------] 1 test from AddTest (0 ms total) [----------] Global test environment tear-down [==========] 2 tests from 2 test cases ran. (0 ms total) [ PASSED ] 1 test. [ FAILED ] 1 test, listed below: [ FAILED ] AddTest.ShouldAddOneAndTo 1 FAILED TEST  However, before being able to run everything, InitGoogleTest() is implemented somewhere in the libraries we just compiled. That means we need to tell the compiler to link the Google Test libraries to our own application.\nAdd libraries as arguments to the compiler while linking. Remember to first use the -c flag, and afterwards link everything together.\n Bringing everything together:\n Wouters-MacBook-Air:debugging wgroeneveld$ g++ -I$GTEST_DIR/include -c gtest-main.cpp Wouters-MacBook-Air:debugging wgroeneveld$ g++ -I$GTEST_DIR/include -c gtest-tests.cpp Wouters-MacBook-Air:debugging wgroeneveld$ g++ gtest-main.o gtest-tests.o $GTEST_DIR/build/libgtest.a $GTEST_DIR/build/libgtest_main.a Wouters-MacBook-Air:debugging wgroeneveld$ ./a.out [==========] Running 2 tests from 1 test case. [----------] Global test environment set-up. [----------] 2 tests from AddTest [ RUN ] AddTest.ShouldAddOneAndTo  As you can see, it can be handy to create a shell variable $GTEST_DIR that points to your own Google Test directory.\nC. \u0026lsquo;Debugging\u0026rsquo; with GTest Going back to the crackme implementation, a simplified method that verifies input is the following:\nint verify(char* pwd) { return !strcmp(pwd, \u0026#34;250382\u0026#34;); // include string.H } Write a set of tests for the above method. Simply copy it into the test file, or include it from somewhere else. You should at least have the following cases:\n right password entered wrong password entered empty password (what about NULL or \u0026quot;\u0026quot;?)  Use the GTest macro EXPECT_TRUE and EXPECT_FALSE. See Google Test Primer.\n  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/structs-labs/",
	"title": "1.4: Structs",
	"tags": [],
	"description": "",
	"content": " We are (still\u0026hellip;) at War! We\u0026rsquo;re at war! The orcs are attacking and are looking very hungry! Look at them! (img src)\n2. Modelling the orcs Let us try to model these filthy beasts. Ask the user for a number. That number is the amount of orcs in the army. Create as many struct instances with random property values and print these on the screen. An orc has the following properties (both simple numbers, between 1 and 10, use rand() from stdlib):\n attack life   INPUT: 3 OUTPUT: orc 1: attack 3, life 5. orc 2: attack 5, life 6. orc 3: attack 1, life 1.  Tips:\n Do not forget to generate a new seed for the random value, see the rand() docs. Creating a separate function generate_orcs() will keep your main() function short and clean. The function will return a list of orcs, the \u0026ldquo;army\u0026rdquo;, so to speak. Remember that returning an array is of type Orc*.  The generate method will look like this:\nOrc* generate_orcs(int amount) { Orc* army = malloc(sizeof(Orc) * amount); // add stuff to army  return army; } Details on how the malloc() function works will be explained later.\n3. Orcs eating each other?? Vowels did not seem to fully satisfy them, now they are turning on each other!? All the better for us. Expand the program such that the first orc fights the next one. (life minus attack). Create a function Orc fight(Orc attacker, Orc defender). Is the defender still alive after the attack? Then he is victorious (and will be returned). Print the last man stending. Input stays the same.\n INPUT: 3 OUTPUT: orc 1: attack 3, life 5. orc 2: attack 5, life 6. orc 3: attack 1, life 1. orc 1 VS 2: 2 wins (6 - 3 = 3 life left) orc 2 VS 3: 2 wins (1 - 5 = dead) orc 2 is victorious!  Tips:\n You will need to loop through all orcs and take two elements out of the array to pit them against each other. Reassign Orc winner = army[0] with the result of the fight() function, within the loop. If both orcs survive, the first one wins.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/lab2_rocketlaunch/",
	"title": "2.4: Launch that rocket !!",
	"tags": [],
	"description": "",
	"content": "   image source: businessinsider.com   First task The first task that the Arduino should do for us is oscillate a LED at 1 Hz. Tip:  \nMake one LED oscillate using the \"Timer/Counter1 Overflow Interrupt\"  one LED oscillates at 1 Hz    Multiple tasks Let\u0026rsquo;s assume that one task is the original blinking LED which oscillates at 1 Hz. Now we want a second application which oscillates 3 times every second.\nMake two LEDs oscillate at different frequencies using the \"Timer/Counter1 Overflow Interrupt\"  one LED oscillates at 1 Hz one LED oscillates at 3 Hz    Start the countdown in \u0026hellip; 3 \u0026hellip; 2 \u0026hellip; 1 \u0026hellip; The bare-metal \\(rocket\\) on the top of this page needs to be launched. Because of the huge amount of exhaust it should be triggered after a countdown. This gives the poor operator sufficient time to get to a safe distance.\nAfter the launch button is pressed, a countdown is started. The countdown starts at 10 and goes to 0. Once the countdown is ongoing, the 1 Hz LED should flash. In the final 3 seconds, the second 3 Hz LED should join the show. When the countdown reaches 0, both LEDs should stay on.   Pull-up resistor: https://www.youtube.com/watch?v=wxjerCHCEMg\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch3-pointers/practical-use/",
	"title": "3.2: Practical Use of Pointers",
	"tags": [],
	"description": "",
	"content": " 1. Changing values around Because in C everything passed by-value, we can manipulate the values of variables in a function that has been declared outside with pointers. In Java you can also change the value of member variables in objects, but not primitives! How do you switch two numbers without giving anything back?\n#include \u0026lt;stdio.h\u0026gt;void swap(int *px, int *py) { int temp; temp = *px; *px = *py; *py = temp; } int main() { int x = 10, y = 20; swap(\u0026amp;x, \u0026amp;y); printf(\u0026#34;(%d, %d)\\n\u0026#34;, x, y); // print (20, 10) } mermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; x[x10] y[y20] px{px} py{py} temp[temp] px --|\u0026x, address-of stack-var x| x py --|\u0026y, address-of stack-var y| y temp -.-|*px, follow pointer for the value| px  Something like that is unthinkable in Java - we need extra tricks for that, such as passing objects. Of course this implementation is also disadvantageous: is it clear to the caller that variables are being changed? Not really. High-performance algorithm implementations benefit from these possibilities. Clear domain-driven applications are not: a higher language is used for that.\n2. Not chaining values around: const To prevent further confusion, it is possible to mark pointers with the const keyword, meaning the value should not be changed. The pointer can still point to another value! As such, this is by no means a \u0026ldquo;constant\u0026rdquo;, like in many other traditional programming languages. Take the above example, and change swap\u0026rsquo;s signature to void swap(const int *px, const int *py). While compiling the code, the following errors are generated:\n test.c:5:9: error: read-only variable is not assignable *px = *py; ~~~ ^ test.c:6:9: error: read-only variable is not assignable *py = temp; ~~~ ^ 2 errors generated.  With the const keyword, we prohibit programmers from using *ptr = ... - that is, assigning another value as a dereferenced pointer. ptr = \u0026amp;temp is still possible, however. If you do not want pointers to change addresses, use const int* const px. That\u0026rsquo;s right, two times const - this is not a mistake. This reads, from right to left, as:\n px is a constant pointer to an int constant  Introducing the second const gives the following error when attempting to change the pointer itself:\n test.c:5:8: error: read-only variable is not assignable px = \u0026temp; ~~ ^ 1 error generated.  In practice, try to use as many constant variables as possible, if you want to make sure the passed values stay the same.\n3. Arithmetics with pointers Pointers and arrays go hand-in-hand in C. Pointers can be moved around by adding and subtracting. On pointers you can also perform operations such as ++ and -- that move the pointer in the memory one place to the left or right. With char * text = \u0026quot;sup\u0026quot; the pointer refers to the first character:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD A{*text} A--|begin van array|C['s'] A-.-D['u'] A-.-E['p'] A-.-F['\\0']  Creating an own version of printf(\u0026quot;%s\u0026quot;, tekst) could be implemented by looping through the pointer until nothing is left to print, like this:\nvoid print_text(char *txt) { while(*txt != \u0026#39;\\0\u0026#39;) { printf(\u0026#34;%c\u0026#34;, *txt); txt++; } } Notice txt++. We simply point to the next possible value in the memory space, which hopefully is still a character. If it is not, and it came from a string, it will be ended with \\0. Adding some value beyond the limit will result in calling upon unintended memory values, resulting in possible glitches. But C will not crash, it is very robust. You should pay extra attention while fiddling about with pointers! For instance:\nIn C, a[i] exactly the same as *(a + i)!\n #include \u0026lt;stdio.h\u0026gt;int main() { char txt[4] = \u0026#34;hey\u0026#34;; char* ptr = txt; char otherstuff[10] = \u0026#34;other\u0026#34;; for(int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;%c\u0026#34;, *ptr); ptr++; } } Depending on your compiler, the above code will print \u0026ldquo;hey ot\u0026rdquo;, meaning your ptr pointer is pointing to the next variable on the local stack after the four characters \u0026ldquo;h\u0026rdquo;, \u0026ldquo;e\u0026rdquo;, \u0026ldquo;y\u0026rdquo;, \u0026ldquo;\\0\u0026rdquo;, from the txt variable, are processed within the for loop. We will go more into detail on this in chapter 4.\nWhat happens when I change txt[4] to txt[3]?\n  Jumping to the next available address space also works with structures instead of a character array:\n#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; typedef struct Doos { int one; int two; } Doos; int main() { Doos doos1 = { 1, 2 }; Doos doos2 = { 3, 4 }; Doos* doosje = malloc(sizeof(Doos) * 2); doosje[0] = doos1; doosje[1] = doos2; for(int i = 0; i \u0026lt; 2; i++) { printf(\u0026#34;doos: one %d two %d\\n\u0026#34;, doosje-\u0026gt;one, doosje-\u0026gt;two); doosje++; } return 0; } The only problem here is that we cannot loop \u0026ldquo;until the end\u0026rdquo; using while(*doosje) { ... }. For that to work, we need linked lists (see lab 2).\nIn C, the new keyword does not exist. Creating instances is done using malloc() instead.\n 4. Linked Lists You will discover in exercise \u0026lsquo;the ancient library\u0026rsquo;, you can link different struct instnaces together to create a list of items, instead of simply using Arrays or other existing data structures. Internally in the C libraries, pointers are applied to connect elements of a collection. Let us try to do the same.\nThis is how the memory structure of your C code looks like without initializing any single variable:\n \nGiven the following structure:\nstruct node { char* name; char* value; struct node* next; }; When instantiating a node element using malloc(), we create a new variable on the heap instead of the stack:\n \nHowever, this representation is incomplete! We create a new local variable, a pointer, and this pointer is actually also a variable on the stack. So, this code:\nvoid create_node() { node* newelement = malloc(sizeof(node)); newelement-\u0026gt;name = \u0026#34;something\u0026#34;; newelement-\u0026gt;value = \u0026#34;value\u0026#34;; newelement-\u0026gt;next = NULL; } Reserves some space on the heap, but also creates a local variable named newelement on the stack:\n \nThe next value is pointing to NULL (\u0026ldquo;nothing\u0026rdquo;), hence the white arrow in the right side of the Figure. Now, what if I want to create a second element, and connect both together? A second local variable reserves a second block on both the stack and the heap:\n \nNow, we want to assign the second element to the next property of the first element. That\u0026rsquo;s very simple with the statement newelement-\u0026gt;next = newelement2;. Now, our memory looks like this:\n \nNotice the changed arrow in the right side of the Figure. Ok, what if we want to loop over all elements by following the arrows from each element, starting with the first, what happens with our variables in the memory space? A new method creates a new chunk in the stack space, where a new variable will be created:\nvoid print(node* printer) { while(printer != NULL) { printf(\u0026#34;%s \\n\u0026#34;, printer-\u0026gt;value); printer = printer-\u0026gt;next; } } void main() { node* head = create_node(); node* tail = create_node(); head-\u0026gt;next = tail; print(head); }  \nIn the above Figure, printer points to the first value in the heap, which is the same as the variable head. When the while() loop starts doing it\u0026rsquo;s work, the variable will point to the next value, and the next, and the next, until it points to NULL.\nThis will become clear in the exercise when you will implement these concepts yourself.\nWhen changing the value of printer, the value of head stays pointing to the first element of the heap! This is because the variable is a copy on the stack.\n What if we want to change the pointer of head using another variable? Then you will need double pointers, or node**:\nvoid change_ptr(node** ptr_to_ptr, node* new_value) { *ptr_to_ptr = new_value; }"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch4-debugging/",
	"title": "4: Debugging",
	"tags": [],
	"description": "",
	"content": " Chapter 4 Debugging in C Important concepts to grasp:\n Breakpoints, stepping into/over, continuing Inspecting the stack and the heap Disassembling, objdumping  Recommended Reading  The GNU Project Debugger Documentation Hackme: exploiting heap bugs Google Test Primer  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/lab2_threadsmgmt/",
	"title": "6.4: Threads",
	"tags": [],
	"description": "",
	"content": "    p.dinobook { color: #7E7E7E; font-size: 14px; font-weight: 300; letter-spacing: -1px; padding-top: 0px; margin-top: -20px; text-align: center; }  source: SILBERSCHATZ, A., GALVIN, P.B., and GAGNE, G. Operating System Concepts. 9th ed. Hoboken: Wiley, 2013.\nCreating and inspecting threads  Write a C-program that has 3 threads. Each threads announces its existence (through a printf) and their PIDs.\n Write a C-program that creates 4 threads\n every of the threads checks which numbes (\u0026lt;10k) are prime every child reports only numbers that are prime, together with its own PID   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/ecosystems/",
	"title": "1.5: C Ecosystems",
	"tags": [],
	"description": "",
	"content": " Separation of concerns: functions in different C files To make the division clearer, we prepare the following C code, split into different files:\n// hello.c char* hello() { return \u0026#34;heykes\u0026#34;; } // main.c #include \u0026lt;printf.h\u0026gt;int main() { printf(\u0026#34;%s\u0026#34;, hello()); return 0; } The main function has no knowledge of hello() because it lives in a different source file. This will be fine if we link the machine code together after compiling. compiling main.c separately gives this:\n Wouters-MacBook-Air:cmake-build-debug wgroenev$ gcc -c main.c main.c:5:18: warning: implicit declaration of function 'hello' is invalid in C99 [-Wimplicit-function-declaration] printf(\"%s\", hello()); ^ 1 warning generated.  It is a WARNING - not an ERROR - so it still compiles! Wow! That is thanks to the -c flag (compile only). The warning is easily solved with a forward function declarations before the main function: char* hello ();. This is the crucial difference between declaration and definition. However, the problems are not yet solved if we want to link this without hello.c:\n Wouters-MacBook-Air:cmake-build-debug wgroenev$ gcc main.o Undefined symbols for architecture x86_64: \"_hallo\", referenced from: _main in main.o ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation)  Okay, so now a blocking ERROR was generated. We also need the hello.o binaries to arrive at a successful working program. For that, we first have to execute gcc -c hello.c and thengcc main.o hello.o -o hey.\nWith the UNIX tool nm we can view the addresses that the linker needs to arrive at the hey executable. Try opening hello.o with a text editor. You then see something like this:\n cffa edfe 0700 0001 0300 0000 0100 0000 0300 0000 f001 0000 0020 0000 0000 0000 1900 0000 8801 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 7800 0000 0000 0000 1002 0000 0000 0000 7800 0000 0000 0000 0700 0000 0700 0000 0400 0000 0000 0000 5f5f 7465 7874 0000 0000 0000 0000 0000 5f5f 5445 5854 0000 0000 0000 0000 0000 0000 0000 0000 0000 0d00 0000 0000 0000 1002 0000 0400 0000 8802 0000 0100 0000 0004 0080 0000 0000 0000 0000 0000 0000 5f5f 6373 7472 696e 6700 0000 0000 0000 5f5f 5445 5854 0000 0000 0000 0000 0000 0d00 0000 0000 0000 0700 0000 0000 0000 1d02 0000 0000 0000 0000 0000 0000 0000 0200 0000 0000 0000 0000 0000 0000 0000 5f5f 636f 6d70 6163 745f 756e 7769 6e64 5f5f 4c44 0000 0000 0000 0000 0000 0000 1800 0000 0000 0000 2000 0000 0000 0000 2802 0000 0300 0000 9002 0000 0100 0000 0000 0002 0000 0000 0000 0000 0000 0000 5f5f 6568 5f66 7261 6d65 0000 0000 0000 5f5f 5445 5854 0000 0000 0000 0000 0000 3800 0000 0000 0000 4000 0000 0000 0000 4802 0000 0300 0000 0000 0000 0000 0000 0b00 0068 0000 0000 0000 0000 0000 0000 0200 0000 1800 0000 9802 0000 0400 0000 d802 0000 2400 0000 0b00 0000 5000 0000 0000 0000 0200 0000 0200 0000 0200 0000 0400 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 5548 89e5 488d 0500 0000 005d c368 6579 6b65 7300 0000 0000 0000 0000 0000 0000 0d00 0000 0000 0001 0000 0000 0000 0000 0000 0000 0000 0000 1400 0000 0000 0000 017a 5200 0178 1001 100c 0708 9001 0000 2400 0000 1c00 0000 a8ff ffff ffff ffff 0d00 0000 0000 0000 0041 0e10 8602 430d 0600 0000 0000 0000 0700 0000 0000 001d 0000 0000 0100 0006 1200 0000 0e02 0000 0d00 0000 0000 0000 1900 0000 0e04 0000 3800 0000 0000 0000 0100 0000 0f01 0000 0000 0000 0000 0000 0800 0000 0f04 0000 5000 0000 0000 0000 005f 6861 6c6c 6f00 5f68 616c 6c6f 2e65 6800 4c5f 2e73 7472 0045 485f 6672 616d 6530 0000  Beautiful, but not very clear. nm does help some:\n heykesWouters-MacBook-Air:cmake-build-debug wgroenev$ nm hallo.o 0000000000000038 s EH_frame0 000000000000000d s L_.str 0000000000000000 T _hello 0000000000000050 S _hello.eh Wouters-MacBook-Air:cmake-build-debug wgroenev$ nm main.o 0000000000000060 s EH_frame0 0000000000000037 s L_.str U _hallo 0000000000000000 T _main 0000000000000078 S _main.eh U _printf  You can see that in main.o the function _hello is assigned an unknown address (hence the U). This means that the left hand should assume that it is yet to come - and luckily it is correctly defined in hello.o at address 0000000000000000 (there is only 1 function).\nThis is the way the files will be coupled to each other:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD A[hello.c] B[main.c] Chello.o] Dmain.o] E{hey executable} E -- C E --|\"search main() via linker\"|D C -- A D -- B D -.-|\"search hallo() via linker\"|C  Functions that have been declared in other source files must therefore be redefined (possibly with the external keyword) in your own source file where you wish to use the function. This way the compiler knows that there is a function with that signature, but \u0026ldquo;he will still come across it\u0026rdquo;. This will be further elaborated in the next labs.\nCompiling everything We use the UNIX GNU gcc compiler to compile C source files and convert them into binaries. The simplest possible way to do so is:\n gcc *.c\n Due to the lack of a target file name, the compiler creates an \u0026ldquo;a.out\u0026rdquo; file that you can execute (chmod +x has already been done for you). You can specify this with the \u0026ldquo;-o\u0026rdquo; flag. If you have something more to link, put everything in a row one after the other.\nHowever, there are still a lot of compiler options that are explained at gcc.gnu.org that you can play with.\nWhen targeting another platform, you will need a cross-compiler that compiles on your computer for another computer. That is, the instruction set might differ! (64 or 32-BIT, RISC/ARM, \u0026hellip;) Instead of using the default GCC compiler: gcc bla.c, you will download and install a custom cross-compiler and evoke it the same way: arm-eabi-none-gcc bla.c. The GBA or RaspberryPi for instance have an ARM chip-set and require this cross-compiler. This differs from most x86 chip-sets that leverages gcc.\n Are you still cross-compiling if you are compiling on an ARM machine yourself, using gcc, compiled for that chip-set? What if you compile code on the Raspberry for your laptop?\n  Step 1: compiling As seen in the above schematic, executing your source code requires the activation of two steps: compiling (1), and linking (2). C Preprocessor flags get parsed just before compiling. Simply calling the gcc compiler executes all steps at once. Only compiling is done using the -c statement (source input) and providing the source files as arguments, producing object files, which can be then linked into a binary.\nStep 2: linking After obtaining object files it is simply a matter of concatenating them (\u0026lsquo;linking\u0026rsquo;), to create the native executable binary file, using the -o flag and providing the object files as arguments. After linking, inspecting the disassembly (see chapter 4 on how to do so in detail) shows the concatenated results.\nRepeatedly compiling (1) using a script It is annoying to have to type the same command all the time, so a simple alternative is to put your gcc command in a shell script:\n#!/bin/sh clear \u0026amp;\u0026amp; gcc -o mystuff source.c \u0026amp;\u0026amp; ./mystuff (2) Makefiles In the C world there is such a thing as a \u0026ldquo;Makefile\u0026rdquo; that defines which source files should be compiled, and in which order. This is useful for large applications where an overview must be kept.\nWith Makefiles you can describe \u0026ldquo;targets\u0026rdquo; that perform certain actions for you. For example, cleaning up binaries, compiling and linking, all as a separate step. Stringing steps together is of course also possible.\n.DEFAULT_GOAL := all CC=gcc clean: rm -rf *.o rm -rf *.out compile: $(CC) -c main.c -o main.o link: $(CC) -o main.out main.o all: clean compile link  Typically, the compiler used is set as a shell variable (CC = gcc). You can see here that compiling (gcc with the -c option does not link) and linking is split into separate make \u0026lsquo;actions\u0026rsquo;. This is not really necessary in our exercises, but shows the organizational strength of Make here.\nExecuting the above steps can be done using the make command and a default goal (all), or make compile for a specific goal (executes the \u0026lsquo;compile\u0026rsquo; steps only).\nFor more information on the correct Makefile syntax, see the GNU make documentation.\nCreate a Makefile that contains two targets: compile and run. The default target should execute both in sequence. As for what to compile, write a simple program that outputs \u0026ldquo;hello, (name)\u0026rdquo;. The name is something you ask from the user using the stdio function gets().\n  (3) IDEs Lightweights A source file consists of simply plain text. Any text editor is sufficient to write your C program. However, it may be useful to use Sublime Text or Visual Studio Code. These modern powerful editors have built-in auto-completion and build tools.\n Sublime Text 3 Build Systems en C/C++ and docs Visual Studio Code C/C++ integration  We will not stop old-school fans from using Emacs or Vi(m).\nHeavyweights CLion is the perfect cross-platform and cross-compiler candidate to do the heavy C/C++ lifting for you, and it comes with integrated debugging, stack inspection, and everything else you might expect from an IDE. If you are familiar with IntelliJ, you will love CLion: it\u0026rsquo;s built on the same platform (IDEA) - even most shortcuts are the same.\nCLion is not free, but it is highly recommended for students (and they get a free license if you register with your university e-mail address). CLion works with CMake: CMakeLists.txt contains instructions to generate aMakefile:\n cmake_minimum_required(VERSION 3.10) project(my_little_pony) set(CMAKE_CXX_STANDARD 11) add_executable(my_little_pony main.cpp biblio.cpp biblio.h animals.cpp animals.h)  A simple CMake file is much easier to read and write than a Makefile. See CMake tutorial for more information. CLion manages the add_executable arguments for you: adding new files to your project will also automatically add them to the list.\nSince CMake builds Makefiles and Makefiles use cmdline to evoke the compiler, you are essentially using high-level tools that use low-level tools. This makes it easier to repeatedly compile bigger projects, instead of calling gcc file.c yourself every single time.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD cmake[CMake] make[Makefiles] cmd[gcc \u0026 cmdline] cmake -- make make -- cmd  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/theory3_interrupt/",
	"title": "2.5 The internals of interrupts",
	"tags": [],
	"description": "",
	"content": "   The internals Now that you have an understanding of how interrupts work, let\u0026rsquo;s dive a bit deeper into the interal workings.\nThe processor has a hardware component that allows hardware interrupts. When a certain event occurs the corresponding wire goes high. This makes one (or more) bits of this interrupt vector high. This triggers the internal Interrupt unit. The image below shows the available interrupts for the AT Mega.\n  The interrupt vector   When an Interrupt Request is triggered and the interrupt is allowed, the processor will jump to another function in program. This function is called the Interrupt Service Routine. When this function is finished, the processor continues with the next instruction that would have been executed before the interrupt occured.\nWhen looking at the image above, vector number 14 (or 13, if we start counting at 0x0) should look familiar: TIMER1_OVF. Below there are two screenshots of disassembled code. The example on left is showing an example on a binary that doesn\u0026rsquo;t have interrupts. In that example it is clear that the complete interrupt vector is empty. The example on the right is showing an interrupt vector that has an entry on position 13. Whenever this signal goes high, the processor jumps to the function at address 0x90.\n  The interrupt vector without an ISR      The interrupt vector with an ISR     The interrupt service routine     What happens if we have an in(-terrupt)ception, read as: an interrupt while an interrupt is being handled ?\n  TODO: order\n TODO: nested interrupts are possible, though it requires user software to re-enable interrupts\n -- Take aways After studying this chapter you should:\n be able to target specific bits in a register at a specific address through C understand how CR\u0026rsquo;s and SR\u0026rsquo;s work understand how timers work understand what Interrupts are  Useful links:  megaAVR Data Sheet   Arduino UNO schematic    "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch3-pointers/lab/",
	"title": "3.3: The Ancient Library",
	"tags": [],
	"description": "",
	"content": " The Ancient Library  Stuff just got interesting: you find yourself inside an extremely old library, where things clearly have not been touched for ages. A green glowing ball rests in the center of the room, giving the books an odd, but compelling color. Do you dare to touch the books? Let us go ahead and clean this place up a bit. (img src)\n 1. Modeling the books The back of the first row of books is barely readable, but you can distinguish the following titles and authors:\n Cleaning the streets Beyond the Gate, by Ulder Ravengard Beyond the depths of the Underdark, by Drizzt Do\u0026rsquo;Urden Ancient Aberrations and how to prevent them, by Elminster Aumar Killing people with cows: the ins and outs of Wild Magic, by Neera  How should we proceed to model the concept of a book? Right, a struct! Keep track of the title and the author using char* properties.  Proceed with caution and whatever you do, do not directly look into the green light! Use the following blueprint:\n#define SIZE 4 Book* create_books() { // ?? } void print_books(Book* library) { // ?? } int main() { Book* library = create_books(); print_books(library); // should print the above list ([title], by [author])  return 0; } 2. Linking things together The strcuture you provided can be expanded with a third property: Book* next, pointing to the next element in the row. That way, when looping through all books, we simply need to follow the \u0026lsquo;next\u0026rsquo; pointer, until a NULL is reached, indicating the end of the library. This technique makes it possible to loop through things without knowing it\u0026rsquo;s size!\nRework your implementation by removing the #define SIZE 4 statement, and by relying on the next pointer in the print_books() method.\nTips:\n What should the value of next be when creating the book instances in create_books()? What should that function return? A handle to what? You can use while(ptr) { ... } instead of a for loop. The value within the while() statement always evaluates to true, unless a \u0026ldquo;nullpointer\u0026rdquo; (a value of 0 or NULL) is detected. That is exactly what we want. Another method to ease use of the malloc() statements might come in handy, such as Book* create_book(char* title, char* author).  3. Cleaning up the library The place looks dusty, doesn\u0026rsquo;t it?  Also, the books seem to be placed in a random order. Why don\u0026rsquo;t we take the time, now that we are here and enjoy the green glow, to order these books alphabetically by author? You can ignore the surnames, simply sort on the property author. That is, the expected output of your program should be:\n Beyond the depths of the Underdark, by Drizzt Do'Urden Ancient Aberrations and how to prevent them, by Elminster Aumar Killing people with cows: the ins and outs of Wild Magic, by Neera Cleaning the streets Beyond the Gate, by Ulder Ravengard  Create and call void sort_books(Book* library) before printing them.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; H{head} T{tail} A[book 1] B[book 2] C[book 3] D[book 4] NNULL] A --|next| B B --|next| C C --|next| D D --|next| N H -- A T -- B  Tips:\n Use the strcmp() function from \u0026lt;string.h\u0026gt; to compare two strings. Sorting a linked list is not as difficult as you might think. You will need some sort of swapping function. Take a look at the above drawing. If book 4 needs to be first, how do you swap it with book 1, while keeping the links intact? Use recursion to repeatedly call sort_books() within the same function. Which book should be placed in the beginning? What should you process next? Think in terms of head and tail.  4. Wild Surge! ASC/DESC  A sudden gust of wind enters the old library. You immediately halt what you were doing to carefully listen if imminent threats are upon you and your party. A cloaked figure swings open a side-door and starts casting a spell that sounds very unfamiliar to you. Praeses, Alia, Fero\u0026hellip; An alteration, but which one?! Quick, hide the books! But alas, it was too late\u0026hellip;  While the spell completes, you hear the figure cursing \u0026ldquo;annoying wild surges!\u0026rdquo;. The voice sounds like a woman. She rushes off, but the part of her face you were able to catch in the glimpse of an eye seems oddly familiar\u0026hellip; Suddenly, you know it. The book! The cow book! That was the author! Neera\u0026hellip;\n Neera managed to completely reverse our sorting strategy, sorting Z to A instead of A to Z. She used a function pointer to encapsulate strcmp(). The following is your main function:\nint main() { Book* library = create_books(); neera_encounter(); // changes a function pointer from asc to desc  sort_books(library); print_books(library); // prints Z -\u0026gt; A  return 0; } Create a function pointer that is initialized to the address of your ascending sorter. Neera her Wild Magic switches this to the address of a descending sorter. That pointer will be used inside sort_books() instead of strcmp().\nTips:\n Re-read chapter 3 (pointers)! You will need two extra functions, asc() and desc(), besides neera_encounter().  5. Do you rest until fully healed?  The rumble of Neera\u0026rsquo;s spell made your head rush and you fill dizzy. Maybe it would be better for you and your party to stay for the night and set up camp. During the night, you make the time to write up on the past events. It looks like it will be quite a thick book, something new to add to the old library. Now, should you add the book at the beginning of the row, or all the way at the end?\n Create a function called void add_book(Book* library, Book* book), that adds a new book to the end of the library.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; new(new book) A[book 1] B[book 2] NNULL] B -.-|next| new new --|next| N A --|next| B  That was quite simple, wasn\u0026rsquo;t it? What if we want it to add new books to the beginning of the library? You cannot change the Book* library pointer as it is copied over by-value. For this to work, we need to change the signature to a pointer of a pointer: void add_book(Book** library, Book* book).\nUse the following main function to test your code:\nint main() { Book* library = create_books(); Book* newbook = create_book(\u0026#34;My adventures\u0026#34;, \u0026#34;The Hero\u0026#34;); // add newbook to the library. But how?  print_books(library); return 0; }"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch5-introos/",
	"title": "5: Intro in OS",
	"tags": [],
	"description": "",
	"content": " Chapter 5 5.1: Intro to OS using Linux\n Types of operating systems Linux Got Root ? On files and such  5.2: (lab) Getting your CLI-feet wet\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/ecosystems-labs/",
	"title": "1.6: Splitting up Code",
	"tags": [],
	"description": "",
	"content": " Building with Makefiles It is time to split up our Orc exercise code into different parts:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD E{Executable} A[main.c] AAmain.o] B[orcs.c] BBorcs.o] D[orcs.h] E -- AA E -- BB AA -- A AA -- D BB -- B BB -- D  Create four different files:\n orcs.h - this is where your struct definition resides. orcs.c - this is where your methods related to orcs reside. Include the orc header file. main.c - this is where your main method resides. Include the orc header file. Makefile - builds everything. Create a compile, link, and clean target.  Compile both C files with separate gcc -c commands, merging them together with a third command, as seen in the previous section.\n  When you think you can manage using the gcc command in the commandline, automate everything by leveraging the power of Makefiles.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/",
	"title": "6: Tasks",
	"tags": [],
	"description": "",
	"content": " Chapter 6 6.1: Process management\n What\u0026rsquo;s in a process ? Run process !  Process Control Block Process state Open files list  Creating processes  6.2: (lab) Processes\n6.3: Thread management\n What\u0026rsquo;s in a thread ? Why would we want multiple threads ?  Amdahl\u0026rsquo;s law  Creating threads  Pthreads   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch7-stack/",
	"title": "7: The Stack &amp; The Heap",
	"tags": [],
	"description": "",
	"content": " Chapter 7 The Stack \u0026amp; The Heap "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch8-memory/",
	"title": "8: Memory Management",
	"tags": [],
	"description": "",
	"content": " Chapter 8 Memory Management "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch8-memory/memory/",
	"title": "8.1: Memory management",
	"tags": [],
	"description": "",
	"content": " "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/ch9-capitaselecta/",
	"title": "9: Capita Selecta",
	"tags": [],
	"description": "",
	"content": " Chapter 9 Capita Selecta "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/exercises/",
	"title": "A. Exercises Assignments",
	"tags": [],
	"description": "",
	"content": " Part A Exercises - Assignments This part contains exercises for students to complete and return to the teaching staff. These will be graded and make up for a portion of the total grading of this course. Every few weeks, new exercises will be made available, so be sure to check out this section now and then.\nThis is an individual assignment. Working together on the same code base is not permitted, and plagiatism will be punished heavily.\n Submitting your exercises Exercises can be submitted via Toledo, when assignments are available on the platform.\nFile submission format: lastname_firstname_[assignmentnr].zip. E.g. for assignment 1: groeneveld_wouter_1.zip. Do not submit single uncompressed files, always adhere to the zip extension.\nDeadlines are also visible on the assignment page via Toledo. Usually, when instructors announce the exercise that has to be submitted, the deadline will be in that same week, on a day specified in the lab (and on toledo), at 12H PM midnight. Be sure to double check the deadline date at Toledo.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/appendix/",
	"title": "B. Appendix",
	"tags": [],
	"description": "",
	"content": " Part B Appendix Recommended reading, instructions, etc\u0026hellip;\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/color_palette/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Color palette by Paletton.com /* Palette color codes */ /* Feel free to copy\u0026paste color codes to your application */ .primary-1 { background-color: #89C9FE } .primary-2 { background-color: #5CB5FF } .primary-0 { background-color: #33A2FF } .primary-3 { background-color: #0E92FF } .primary-4 { background-color: #0186F5 } .secondary-1-1 { background-color: #9593FE } .secondary-1-2 { background-color: #6D6AFF } .secondary-1-0 { background-color: #4844FF } .secondary-1-3 { background-color: #231FFF } .secondary-1-4 { background-color: #0602F6 } .secondary-2-1 { background-color: #FFE081 } .secondary-2-2 { background-color: #FFD450 } .secondary-2-0 { background-color: #FFC924 } .secondary-2-3 { background-color: #FFC000 } .secondary-2-4 { background-color: #FFC000 } .complement-1 { background-color: #FFCA81 } .complement-2 { background-color: #FFB550 } .complement-0 { background-color: #FFA324 } .complement-3 { background-color: #FF9400 } .complement-4 { background-color: #FF9400 } /* end */ body { margin:0; padding: 2em; background: #fff; color: #000; font: 12px/1.33 \"Segoe UI\", \"Helvetica Neue\", Helvetica, sans-serif; text-align:left; } h1 { margin: 0.5em 0; font-size: 200%; } p { margin: 0.5em 0; } .color-table { margin: 2em 2em 5em; border-collapse:collapse; border:none; border-spacing:0; font-size:100%; } .color-table th { padding: 0 1em 0 0; text-align: right; vertical-align: middle; font-size: 100%; font-weight: normal; border: none; } .color-table td.sample { width:6em; height:6em; padding: 10px; text-align:center; vertical-align:middle; font-size:90%; border: 1px solid white; white-space:nowrap; } .color-table td.sample-0 { width:18em; } .color-table.small td.sample { width:3em; height:3em; padding:0; border:none; } .color-table.small td.sample-0 { width:9em; } .color-table .white { margin-bottom:0.2em; color:white } .color-table .black { margin-top:0.2em; color:black } hr { margin: 2em 0 1em 0; border:none; border-bottom:1px solid silver; } #footer { padding:1em; text-align:center; font-size:80%; }    Color Palette by Paletton.com Palette URL: http://paletton.com/#uid=73y0u0kru++fR+ClV+XAF+VZAXh\n Primary color: #89C9FE #89C9FE  #5CB5FF #5CB5FF  #33A2FF #33A2FF  #0E92FF #0E92FF  #0186F5 #0186F5    Secondary color (1): #9593FE #9593FE  #6D6AFF #6D6AFF  #4844FF #4844FF  #231FFF #231FFF  #0602F6 #0602F6    Secondary color (2): #FFE081 #FFE081  #FFD450 #FFD450  #FFC924 #FFC924  #FFC000 #FFC000  #FFC000 #FFC000    Complement color: #FFCA81 #FFCA81  #FFB550 #FFB550  #FFA324 #FFA324  #FF9400 #FF9400  #FF9400 #FF9400     Primary color:        Secondary color (1):        Secondary color (2):        Complement color:         See the HTML source for more details.\nUse the Save / Save As... command in your browser to store the document for latter use.  Generated by Paletton.com © 2002-2014\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/appendix/reading/",
	"title": "1. Recommended reading",
	"tags": [],
	"description": "",
	"content": " Operating Systems Operating System Concepts  Another defining moment in the evolution of operating systems Small footprint operating systems, such as those driving the handheld devices that the baby dinosaurs are using on the cover, are just one of the cutting-edge applications you\u0026rsquo;ll find in Silberschatz, Galvin, and Gagne\u0026rsquo;s Operating System Concepts, Seventh Edition.\n Website: os-book.com\nProgramming in C The (Ansi) C Programming Language  This book is meant to help the reader learn how to program in C. It is the definitive reference guide, now in a second edition. Although the first edition was written in 1978, it continues to be a worldwide best-seller. This second edition brings the classic original up to date to include the ANSI standard.\n Ebook\nExpert C Programming  C programming is a craft that takes years to perfect. A reasonably sharp person can learn the basics of C quite quickly. But it takes much longer to master the nuances of the language and to write enough programs, and enough different programs, to become an expert. This book explains quirks, weird syntax, and more \u0026ldquo;deep C secrets\u0026rdquo;.\n Ebook\nTechniques for memory safety in C  In this essay, first temporal memory errors will be explained. After that the three main techniques to fully prevent these errors will be ex- plored by means of example. Furthermore for each technique the compatibility, with legacy code, and the performance will be discussed to provide a overview of the major advantages and disadvantages.\n Ebook\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/appendix/installing/",
	"title": "2. Installation Instructions",
	"tags": [],
	"description": "",
	"content": " The exercises for this course are to be done on a Linux machine. Because it is not expected that you reinstall your machines (or prepare them for dual boot), there is a virtual machine prepared for you 😃. This virtual machine runs Bodhi which is a lightweight linux distribution that is based on Ubuntu 18.04 LTS.\nSystem Requirements The most crucial resource is disk space. The virtual machine image is 2.4 GB and will be 5.2 GB when extracted. The downloaded image can be removed after installation.\nRecipe for installing the OSC virtual machine  download and install VirtualBox download OSC.ova image: OSC.ova start VirtualBox\n Under File \u0026gt; Import Appliance \u0026hellip; choose OSC.ova  \n reinitialise MAC addresses of all Network cards\n click Import\n wait and have a \u0026nbsp; \n  Select the OSC image and go to Settings  \n Plug in your Arduino Goto USB  \n With USB 1.1 selected, add a USB device (the Arduino)  \n  launch the Virtual Machine \u0026hellip; Welcome to Bodhi !!  \n  FAQ  [WINDOWS] The screen looks very interlaced  Settings \u0026gt; Display Graphics Controller VBoxVGA -\u0026gt; VMSVGA  I want to change the keyboard layout!  (https://www.bodhilinux.com/w/configuring-your-new-bodhi-system/ Go to Menu \u0026gt; Applications \u0026gt; System Tools \u0026gt; System Settings \u0026gt; Keyboard Layout to open the Keyboard Layout dialog box. Click your language from the list and hit Apply Selected.)  I want to be able to copy-and-paste text between my Host (my own computer) and the Guest (Bohdi Linux ISO)!  This is not possible without the installation of an additional package: https://askubuntu.com/questions/22743/how-do-i-install-guest-additions-in-a-virtualbox-vm/22745#22745  I want to install something else such as my own favorite editor!  sudo apt-get install [package] (root password is XXXXXX)  I want to change the resolution of the VirtualBox display  View -\u0026gt; fit to screen, or View -\u0026gt; change resolution to -\u0026gt; pick one.   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/appendix/cheat_sheet/",
	"title": "Cheat sheet",
	"tags": [],
	"description": "",
	"content": " This cheat sheet summarises a set of commands, so you don\u0026rsquo;t have to Google everything.\nLinux commands Below is a brief list of Linux commands. Remember that you can get more info on a command by typing \u0026ldquo;[command] -h\u0026quot;, \u0026ldquo;man [command]\u0026ldquo;, or even google the manpage on Google.\nNavigation    command goal     cd change directory   pwd \u0026lsquo;present working directory\u0026rsquo;   ls list (show content of current directory) - params: -la   mkdir create a directory   history show a history of used commands. Re-execute with ![number].   clear clears all text from terminal window    CLI tools    command goal     rm remove a file/directory - params: -rf   touch create a file   cat print raw file contents to terminal output   grep search for content in a file   vi powerful editor with a steep learning curve (FYI: exiting is through: \u0026ldquo;:q!\u0026ldquo;)   chmod change modifiers of a file (r/w/x/d) - params: +/-[modifier]    Compiling    command goal     gcc GNU C Compiler - params: -c, -o, \u0026hellip;   make Execute a Makefile - params: [target]    System administration    command goal     ps report a snaptshot of the current processes   pstree display a tree of processes   kill send a signal to a process   bg send process to the background   fg retrieve process to the background   jobs list processes in the background    "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/",
	"title": "Operating Systems and C",
	"tags": [],
	"description": "",
	"content": " Operating systems and C "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/osc-course/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]