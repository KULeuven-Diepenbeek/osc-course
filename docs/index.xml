<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Operating Systems and C</title>
    <link>https://kuleuven-diepenbeek.github.io/osc-course/</link>
    <description>Recent content on Operating Systems and C</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-uk</language>
    <managingEditor>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</managingEditor>
    <webMaster>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</webMaster><atom:link href="https://kuleuven-diepenbeek.github.io/osc-course/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1.1: The C programming language</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/intro/</guid>
      <description>The C language is a programming language developed in the &amp;lsquo;70s to make it easier to interface with hardware. C was/is in essence nothing more than a few abstraction layers on top of assembly itself.
A quick intro to C C is an imperative programming language. You will notice this when writing some code yourself: we write instructions as statements. These rules or statements are structured in function and struct types.</description>
    </item>
    
    <item>
      <title>2.1 Arduino UNO</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/theory1_arduino/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/theory1_arduino/</guid>
      <description>&amp;raquo;&amp;nbsp;[Naar de labo opgave](#oef) -- The Arduino UNO is an open-source microcontroller board. It is powered by an off-the-shelf ATMega microcontroller from Microchip  . The datasheet for this family of microcontrollers can be found here  .
  An Arduino UNO. Source. arduino.cc   This datasheet contains a block diagram of the AVR architecture. Nonetheless, most of these components could be found in many other microcontrollers as well.</description>
    </item>
    
    <item>
      <title>4.1: The Easy Way: IDEs</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch4-debugging/debugging-ide/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch4-debugging/debugging-ide/</guid>
      <description>1. The easy way: Debugging using an IDE Arguably one of the better integrated C/C++ IDEs out there is CLion, a toolkit from Jetbrains based on the IDEA platform you all know from IntelliJ. It has exactly the same tools and capabilities but is fully geared towards C and C++. Cross-compiling and toolchain setup is also very easy using CLion. The Figure below is a screen capture of CLion showcasing it&amp;rsquo;s integrated unit testing capabilities which we will expand upon in the coming sections.</description>
    </item>
    
    <item>
      <title>5.1: Intro to OS using Linux</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch5-introos/intro-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch5-introos/intro-os/</guid>
      <description>In the previous chapter the concept of interrupts was introduced. By using these interrupts it becomes easier to execute multiple tasks on a single processor. However, can you imagine developing a complete office-suite using interrupts ?
If more tasks come into play, interrupts will not be the answer to our question. But guess what the answer could be: Operating systems !!!
The image below shows the classic picture when introducing OSes.</description>
    </item>
    
    <item>
      <title>6.1: Processes</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/processes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/processes/</guid>
      <description>One of the three core tasks of an OS is the management of tasks. These different tasks are all running on the same processor. To make this magic happen some form of management is required.
What&amp;rsquo;s in a process ? By definition, a process is an instance of a program. As was dicussed in the &amp;ldquo;C-portion&amp;rdquo; of this course a basic program can be divided in multiple segments. When source code is compiled into a binary, these segments are fixed.</description>
    </item>
    
    <item>
      <title>7.1: Scheduling algorithms</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch7-scheduling/algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch7-scheduling/algorithms/</guid>
      <description>In the previous chapter on Tasks, we&amp;rsquo;ve discussed one of the main responsibilities of an operating system: task management. Well to be fair, we have only been creating tasks and stopping or killing tasks. The necessary component that allows tasks to be run on the processor is discussed in this chapter: the scheduler. For the record, tasks or jobs refer to either processes and/or threads.
The scheduler has two main jobs:</description>
    </item>
    
    <item>
      <title>8.1: The Stack &amp; the Heap</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch8-stack/stackvsheap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch8-stack/stackvsheap/</guid>
      <description>The Stack and the Heap Program Memory  Compiled computer programs are divided into different sections, each with their own specific needs and properties. Together, they form the program memory. The following image represents these sections, from bottom to top:   text Read-only, fixed size. Contains executable instructions.   data Can be modified. Contains global or static variables that are initialized, such as static int i = 5;.</description>
    </item>
    
    <item>
      <title>9.1: Memory management</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch9-memory/memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch9-memory/memory/</guid>
      <description>At multiple times we referred to the registers in processor. These 16 (or at least in that order of magnitude) registers don&amp;rsquo;t suffice to run the complex tasks that are running on our devices. More space is needed !!!
What good is additional space is you can&amp;rsquo;t access it ? As we do in real life we give every house an address. This provides an unambiguous way of addressing ðŸ˜‰ every single house.</description>
    </item>
    
    <item>
      <title>X.1: File systems</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/chx-cs/filesystems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/chx-cs/filesystems/</guid>
      <description>Introduction in Unix filesystems Files in Unix Working daily with files in Unix operating systems will no doubt increase your awareness of the specific ins and outs of the Unix filesystem. As you know from previous chapters, everything is a file in Unix: we have used this to our advantage to inspect the inner workings of a process in the /proc directory.
A file is the smallest possible unit of storage in a unix system.</description>
    </item>
    
    <item>
      <title>1. Integrated C exercise</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/exercises/c-integrated-ex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/exercises/c-integrated-ex/</guid>
      <description>Download the start project here: c-integrated-start.c.
The following functions are given:
 showList() prints the values of a list (no need to modify this) clearList() clears objects and frees memory (no need to modify this) createRandomNode() creates a new object with a random value createListOfItems() creates a list of x random objects main() bootstraps everything.  1. Commandline compiling Create a simplified Makefile which does the following when executing the command make:</description>
    </item>
    
    <item>
      <title>1.2: String Manipulation</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/intro-labs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/intro-labs/</guid>
      <description>We are at War! We&amp;rsquo;re at war! The orcs are attacking and are looking very hungry! Look at them!
  Orcs attacking! source: G.I.   1. String manipulation However, instead of simply killing you, these not so friendly looking beasts target vowels instead of bowels. So when speaking to, they munch and munch, stripping your carefully chosen words of all vowels. How rude. Implement a function called char* munch(char* sentence) that obscures all vowels with an &amp;lsquo;X&amp;rsquo;, and then prints the results.</description>
    </item>
    
    <item>
      <title>1.3: Creating order: Structures</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/structs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/structs/</guid>
      <description>Structs The only way to structure data in C is using the struct keyword:
struct Person { int age; int gender; // no bool, remember?  char name[100]; // do not forget to add a size } We can use this structure to assign values like this:
struct Person jaak; // do not forget &amp;#34;struct&amp;#34; // jaak.name = &amp;#34;Jaak Trekhaak&amp;#34;; - this is too easy - won&amp;#39;t work strcpy(jaak.name, &amp;#34;Jaak Trekhaak&amp;#34;); // include &amp;lt;string.</description>
    </item>
    
    <item>
      <title>2. Testing in C(&#43;&#43;)</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/exercises/c-debugging-testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/exercises/c-debugging-testing/</guid>
      <description>Download the start project here: cpp-testing.cpp. Remember that in order to run this as a Google Test Suite, you need to compile it using g++ and bootstrap GTest in a separate .cpp file where the main() function resides. Go back to the lab notes if you&amp;rsquo;re not sure how to pull this off.
The following code is given:
 date and period structs to represent a date and a period of dates in code.</description>
    </item>
    
    <item>
      <title>2.2: Arduino multi frequencies</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/lab1_arduino-multfreq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/lab1_arduino-multfreq/</guid>
      <description>Time to make some harmonics.
  image source: wikipedia.org   Three&amp;rsquo;s a charm The example below has to be completed. Three LEDs are placed and defined. If you run the code, the left-most LED starts blinking at 1 Hz. You can choose how you want approach this. Either you search for you very own Arduino and rebuild the design. Or, otherwise, you can use a (webbased) simulator like for example Tinkercad.</description>
    </item>
    
    <item>
      <title>4.2: The Hard Way: GDB</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch4-debugging/debugging-gdb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch4-debugging/debugging-gdb/</guid>
      <description>2. The hard way: Command-line debugging using GDB In order to fluently debug binary programs, they have to be compiled with the debug flag, gcc -g. This will add metadata to the binary file that gdb uses when disassembling and setting breakpoints. IDEs automatically add metadata like this when you press the &amp;ldquo;Debug&amp;rdquo; button on them, but since this is a command-line application, we need to do everything ourselves.</description>
    </item>
    
    <item>
      <title>5.2: Getting your CLI-feet wet</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch5-introos/lab1_wetfeet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch5-introos/lab1_wetfeet/</guid>
      <description>Source: Neo
Getting your feet wet This &amp;lsquo;lab&amp;rsquo; consists out of a list to small tasks that introduce you to the command-line interface. None of these tasks require exhaustive manual labour. They should all be accomplished by using the commands.
Navigation  figure out in which folder you are at the moment navigate to the root folder navigate to your home folder, using only 1 command make an alias (man alias) that navigates to your home folder from everywhere within the system  File manipulation  make a folder &amp;ldquo;myVeryOwnFolder&amp;rdquo; navigate into that folder create an empty file: empty.</description>
    </item>
    
    <item>
      <title>6.2: Processes (lab)</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/lab1_processmgmt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/lab1_processmgmt/</guid>
      <description>p.dinobook { color: #7E7E7E; font-size: 14px; font-weight: 300; letter-spacing: -1px; padding-top: 0px; margin-top: -20px; text-align: center; }  source: SILBERSCHATZ, A., GALVIN, P.B., and GAGNE, G. Operating System Concepts. 9th ed. Hoboken: Wiley, 2013.
Creating and inspecting processes  Write a C-program that prints its own PID on the screen.    An example output    Write a C-program that spawns another process. Both parent and child processes announce their existence (through a printf) and their PIDs.</description>
    </item>
    
    <item>
      <title>7.2: Scheduling algorithms (lab)</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch7-scheduling/lab1_algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch7-scheduling/lab1_algorithms/</guid>
      <description>image source: unsplash.com   Let&amp;rsquo;s compare ! We have discussed a number of algorithms the scheduler can use to do it&amp;rsquo;s job. Let&amp;rsquo;s compare them. We assume the following tasks:
 T1: arrives @ 0s, takes 10s, and has priority low T2: arrives @ 1s, takes 2s, and has priority high T3: arrives @ 4s, takes 5s, and has priority medium T4: arrives @ 7s, takes 1s, and has priority high  Compare Threshold, AJWT, and AJCT of the 4 algorithms we&amp;rsquo;ve seen up until:</description>
    </item>
    
    <item>
      <title>8.2: Inspecting memory regions</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch8-stack/inspection-labs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch8-stack/inspection-labs/</guid>
      <description>Accompanying Screencast:
  1. No malloc, no heap Let&amp;rsquo;s look at memory regions of a process that does not call malloc(). This means we will not use the heap just yet. Compile the following code:
#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt; int main() { getchar(); // breaks process until char input  return 0; } To explore the above example, we will introduce getchar() before ending the main() loop, so the program pauses and gives us a change to look under the hood.</description>
    </item>
    
    <item>
      <title>9.2: Deliberate Segfaulting</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch9-memory/lab1_segfault/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch9-memory/lab1_segfault/</guid>
      <description>source: xkcd.com   X A to the Z  Run the program below and verify that it runs without errors
#include &amp;lt;stdio.h&amp;gt; #define WRITE_SIZE 26 #define READ_SIZE 27  int main(void) { int i; unsigned char alphabet[26]; for(i=0;i&amp;lt;WRITE_SIZE;i++) { alphabet[i] = 65 + i; } for(i=0;i&amp;lt;READ_SIZE;i++) { printf(&amp;#34;%2d -&amp;gt; %c (%02x)\n&amp;#34;, i, alphabet[i], alphabet[i]); } return 0; } Recompile the code above, but verify that you have the -0s option added.</description>
    </item>
    
    <item>
      <title>X.2: Real-time Operating Systems</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/chx-cs/rtos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/chx-cs/rtos/</guid>
      <description>Operating Systems In the previous chapters, many aspects are handled that form the Operating System. The image below, linked from Wikipedia, shows the most important components in the Linux kernel.
  source: wikipedia.com   The image above shows:
 Task management Memory management the IO subsystem    The desired situation.      The real situation.     The main goal of the OS is still the same: allow multiple programs and/or users use the same hardware.</description>
    </item>
    
    <item>
      <title>2.3 The timer</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/theory2_timer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/theory2_timer/</guid>
      <description>With our sleeves rolled up and dirt all the way up to our elbows, it&amp;rsquo;s time to grab a coffee and do so reading/studying again. In this section interrupts will be introduced through the use of a timer.
A lot of applications that are built using an Arduino need some sense of time. As mentioned earlier the ATMega has 3 dedicated timers on chip: two 8-bit timers and one 16-bit timer.</description>
    </item>
    
    <item>
      <title>3. Inter-thread communication</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/exercises/tasks_inter_thread_communication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/exercises/tasks_inter_thread_communication/</guid>
      <description>Analyse exercise 6_4_3.c (shown below) and write a report (&amp;lt; 3 pages):  describe what the program does make a chart that plots &amp;lsquo;the elapsed real time&amp;rsquo; the program consumes in function of the number of &amp;lsquo;the number of threads that are contributing&amp;rsquo;  the scale on the X-axis goes from 2 to 300 at least 8 data points should be present in the chart TIP the command time  interpret the chart   hand in the report</description>
    </item>
    
    <item>
      <title>3.1: Pointers and arrays</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch3-pointers/pointers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch3-pointers/pointers/</guid>
      <description>In the schematic examples below, the following concepts can be explicitly distinguished:
 The name of a variable The value of a variable  And the following implicitly:
 The type of a variable The adres of a variable  The type of a variable determines the amount of memory that is freed up to be able to save the value. The value is either a current value or an address that refers to a different value.</description>
    </item>
    
    <item>
      <title>4.3: The Middle Way: TDD</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch4-debugging/testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch4-debugging/testing/</guid>
      <description>Test-Driven Development: Google Test A concept you learned to love in the Software Engineering Skills course.
It&amp;rsquo;s concepts and definitions will not be repeated here, but we will introduce Google Test, a unit testing framework for C/C++ that enables us to write tests to track down bugs and reduce the amount of time needed dabbling in gdb. That is one of the major advantages of using automated test frameworks.</description>
    </item>
    
    <item>
      <title>6.3: Threads</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/threads/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/threads/</guid>
      <description>One of the three core tasks of an OS is the management of tasks. These different tasks are all running on the same processor. To make this magic happen some form of management is required.
What&amp;rsquo;s in a thread ? A process can exist out of multiple threads. Up until now all the processes that were discussed contained one thread.
  The single threaded process    p.</description>
    </item>
    
    <item>
      <title>7.3: Towards real-world schedulers</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch7-scheduling/towards/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch7-scheduling/towards/</guid>
      <description>The before mentioned algorithms are but a select number from an infinite amount of imaginable algorithms that can be thought of. Off course multiple algorithms can also be combined. The combination of round-robin scheduling with priorities is a combo that is used in many real-world schedulers.
How could be mix both algorithms ? One takes priority into account while the other one does not. The only parameter that can tweaked in Round Robin is the time slice.</description>
    </item>
    
    <item>
      <title>8.3: Different Scopes in C</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch8-stack/scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch8-stack/scope/</guid>
      <description>Scoping issues Now that you have some basic knowledge on the stack and the heap, it is time to take a better look at the different scopes present in the C programming language. These concepts are very important because they in part determine whether variables live (or not) - and whether anything is pushed to the local stack (or not). Let&amp;rsquo;s start with a basic example:
#include &amp;lt;stdio.h&amp;gt; void* whats_my_age() { int age = 30; // I&amp;#39;m being generous here!</description>
    </item>
    
    <item>
      <title>9.3: Paging</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch9-memory/paging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch9-memory/paging/</guid>
      <description>A memory management technique that is used both in Linux and all other main operating systems is paging. The core of the concept is similar to segmentation: The main memory is divided into pieces. These pieces are mapped to the hardware and give the programmer the illusion of having a continuous memory space. However, internally these pieces might be spread all over the hardware.
With segmentation there might be the following issue: we need to allocate a segment of 1024 bytes.</description>
    </item>
    
    <item>
      <title>X.3: Device Drivers</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/chx-cs/devdrivers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/chx-cs/devdrivers/</guid>
      <description>General The kernel of an operating system has a lot of different tasks. Some of them we visited in earlier chapters. One task of the OS is the management of the different hardware devices that are typically connected to a processor in a laptop, desktop, or server. The OS has to know how to talk to a certain device. Typically an Application Programming Interface (an API) is provided to the user space, so users can interact with the hardware.</description>
    </item>
    
    <item>
      <title>1.4: Structs</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/structs-labs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/structs-labs/</guid>
      <description>We are (still&amp;hellip;) at War! We&amp;rsquo;re still at war! The orcs are attacking and are looking very hungry! Look at them!
  Orcs attacking! source: G.I.   2. Modelling the orcs Let us try to model these filthy beasts. Ask the user for a number. That number is the amount of orcs in the army. Create as many struct instances with random property values and print these on the screen.</description>
    </item>
    
    <item>
      <title>2.4: Launch that rocket !!</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/lab2_rocketlaunch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch2-interrupts/lab2_rocketlaunch/</guid>
      <description>image source: businessinsider.com   First task The first task that the Arduino should do for us is oscillate a LED at 1 Hz. Tip:  
Make one LED oscillate using the &#34;Timer/Counter1 Overflow Interrupt&#34;  one LED oscillates at 1 Hz    Multiple tasks Let&amp;rsquo;s assume that one task is the original blinking LED which oscillates at 1 Hz. Now we want a second application which oscillates 3 times every second.</description>
    </item>
    
    <item>
      <title>3.2: Practical Use of Pointers</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch3-pointers/practical-use/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch3-pointers/practical-use/</guid>
      <description>1. Changing values around Because in C everything passed by-value, we can manipulate the values of variables in a function that has been declared outside with pointers. In Java you can also change the value of member variables in objects, but not primitives! How do you switch two numbers without giving anything back?
#include &amp;lt;stdio.h&amp;gt;void swap(int *px, int *py) { int temp; temp = *px; *px = *py; *py = temp; } int main() { int x = 10, y = 20; swap(&amp;amp;x, &amp;amp;y); printf(&amp;#34;(%d, %d)\n&amp;#34;, x, y); // print (20, 10) } mermaid.</description>
    </item>
    
    <item>
      <title>4. Pseudo scheduler</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/exercises/scheduler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/exercises/scheduler/</guid>
      <description>image source: youtube.com   Scheduler In this assignment you&amp;rsquo;re going to build a (pseudo) scheduler. A number of tasks will be provided. The scheduler follows the next rules to schedule the presented tasks:
 The scheduler is preemtive and uses a round-robin approach without priorities. The (virtual) time slice is 1 second. If a new job is announcing itself, it gets a time slice right away (last come, first served)  Circular Linked List As should be clear from the theory, the (pseudo) scheduler will need to store the incoming.</description>
    </item>
    
    <item>
      <title>6.4: Threads (lab)</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/lab2_threadsmgmt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/lab2_threadsmgmt/</guid>
      <description>p.dinobook { color: #7E7E7E; font-size: 14px; font-weight: 300; letter-spacing: -1px; padding-top: 0px; margin-top: -20px; text-align: center; }  source: SILBERSCHATZ, A., GALVIN, P.B., and GAGNE, G. Operating System Concepts. 9th ed. Hoboken: Wiley, 2013.
Creating and inspecting threads  Write a C-program that has 3 threads. Each thread announces its existence through a printf() together with its PID.    An example output    Write a C-program that has 1 king thread and n servant threads.</description>
    </item>
    
    <item>
      <title>7.4: Mr. nice guy(lab)</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch7-scheduling/lab2_niceguy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch7-scheduling/lab2_niceguy/</guid>
      <description>image source: amazon.com    Write a program in C that fetches its own PID and priority. Display the PID, the nice value and the priority.    An example output    Adjust the program above (after copying it, off course) so it sleeps for 5 seconds after those operations. Repeat that process for 100 times. Compile and run that program. While that program is running, and is reporting back every 5 seconds:  change the nice value (on another terminal) verify in the reporting that it works change the nice value so the overall priority is at its lowest change the nice value so the overall priority is at its highest     An example output    Adjust the program above (after copying it, off course) so it goes through the exact same changes in priority.</description>
    </item>
    
    <item>
      <title>9.4: Simply browsing through pages</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch9-memory/lab2_browsing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch9-memory/lab2_browsing/</guid>
      <description>image source: wikipedia.com    Get page size on the Linux system in the Virtual Box through a C program   An example output  
 Assume a system with a 32-bit logical addresses and a 4-kB page size. Write a C program that is passed a logical address (in decimal) through command line arguments. Print the page number and the offset for the given address.</description>
    </item>
    
    <item>
      <title>1.5: C Ecosystems</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/ecosystems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/ecosystems/</guid>
      <description>Separation of concerns: functions in different C files To make the division clearer, we prepare the following C code, split into two different files:
File hello.c:
// hello.c char* hello() { return &amp;#34;heykes&amp;#34;; } File main.c:
// main.c #include &amp;lt;printf.h&amp;gt;int main() { printf(&amp;#34;%s&amp;#34;, hello()); return 0; } The main function has no knowledge of hello() because it lives in a different source file. This will be fine if we link the machine code together after compiling.</description>
    </item>
    
    <item>
      <title>3.3: The Ancient Library</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch3-pointers/lab/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch3-pointers/lab/</guid>
      <description>The Ancient Library  Stuff just got interesting: you find yourself inside an extremely old library, where things clearly have not been touched for ages. A green glowing ball rests in the center of the room, giving the books an odd, but compelling color. Do you dare to touch the books? Let us go ahead and clean this place up a bit.
   Source: dublin2019.com   1.</description>
    </item>
    
    <item>
      <title>3.3: The Ancient Library (RTOS)</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/appendix/lab_ll_rtos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/appendix/lab_ll_rtos/</guid>
      <description>The Ancient Library  Stuff just got interesting: you find yourself inside an extremely old library, where things clearly have not been touched for ages. A green glowing ball rests in the center of the room, giving the books an odd, but compelling color. Do you dare to touch the books? Let us go ahead and clean this place up a bit. (img src)
 1. Modeling the books The back of the first row of books is barely readable, but you can distinguish the following titles and authors:</description>
    </item>
    
    <item>
      <title>6.5: Inter task communication</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/intertasks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/intertasks/</guid>
      <description>Having multiple tasks running is all good-and-well. Hey, it is one of the main reasons why the concept of an OS was introduced, remember ? Right, good job !!
It would make sense, though, if different tasks were able to communicate with each other. A distinction should be made between multi-processes and multi-threading. Although both techniques are made for running multiple jobs, the communication between the jobs is much different in both.</description>
    </item>
    
    <item>
      <title>1.6: Splitting up Code</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/ecosystems-labs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch1-c/ecosystems-labs/</guid>
      <description>Building with Makefiles It is time to split up our Orc exercise code into different parts:
mermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD E{Executable} A[main.c] AAmain.o] B[orcs.c] BBorcs.o] D[orcs.h] E -- AA E -- BB AA -- A AA -- D BB -- B BB -- D  Create four different files:
 orcs.h - this is where your struct definition resides. orcs.c - this is where your methods related to orcs reside.</description>
    </item>
    
    <item>
      <title>6.6: Inter task communication (lab)</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/lab3_intertaskcomm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/ch6-tasks/lab3_intertaskcomm/</guid>
      <description>Source: G.I.   Inter process communication These exercises are to be done in a terminal, using the command line interface.
  Open two terminals. On one terminal you start a process that takes some minutes to finish. From the other terminal:
 figure out the process ID of the first process send a kill signal to that first process.  Use unnamed pipes to display all the processes of which you are the owner.</description>
    </item>
    
    <item>
      <title>1. Recommended reading</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/appendix/reading/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/appendix/reading/</guid>
      <description>Operating Systems Operating System Concepts  Another defining moment in the evolution of operating systems Small footprint operating systems, such as those driving the handheld devices that the baby dinosaurs are using on the cover, are just one of the cutting-edge applications you&amp;rsquo;ll find in Silberschatz, Galvin, and Gagne&amp;rsquo;s Operating System Concepts, Seventh Edition.
 Website: os-book.com
Programming in C The (Ansi) C Programming Language  This book is meant to help the reader learn how to program in C.</description>
    </item>
    
    <item>
      <title>2. Linux Installation Instructions</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/appendix/installing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/appendix/installing/</guid>
      <description>The exercises for this course are to be done on the Linux Operating System (OS). For those unfamiliar, Linux is an open source OS that comes in many different forms called distributions. Linux is used extensively worldwide and you will need to use it many times in your future career.
We would of course not ask you to remove Windows to install Linux on your personal machine and installing them side-by-side (called dual boot) is also a hassle.</description>
    </item>
    
    <item>
      <title>Cheat sheet</title>
      <link>https://kuleuven-diepenbeek.github.io/osc-course/appendix/cheat_sheet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Wouter Groeneveld and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/osc-course/appendix/cheat_sheet/</guid>
      <description>This cheat sheet summarises a set of commands, so you don&amp;rsquo;t have to Google everything.
Linux commands Below is a brief list of Linux commands. Remember that you can get more info on a command by typing &amp;ldquo;[command] -h&amp;quot;, &amp;ldquo;man [command]&amp;ldquo;, or even google the manpage on Google.
Navigation    command goal     cd change directory   pwd &amp;lsquo;present working directory&amp;rsquo;   ls list (show content of current directory) - params: -la   mkdir create a directory   history show a history of used commands.</description>
    </item>
    
  </channel>
</rss>
